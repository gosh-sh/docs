{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Git Open Source Hodler","text":"<p>(Yes, it's Hodler).</p> <p>GOSH \u2014 a Decentralized Cloud to build consensus around your documents.</p> <p>A Git on-chain and DAO platform, GOSH offers a suite of ready-to-use embedded applications to write and deploy code, conduct peer reviews, run decentralized Hackathons and Grant Programs, and much more. GOSH is a Public Chain with Ethereum L2 cross-chain functionality, built on the groundbreaking Acki Nacki consensus protocol, which supports a Freemium business model (gas-free transactions).</p>"},{"location":"#architecture","title":"Architecture","text":"<ol> <li>Build a scalable multithreaded, multisharded content addressable blockchain</li> <li>Implement Git using smart contracts</li> <li>Implement DAO on top of that Git to allow building consensus around the code</li> <li>Formally verify the smart contracts</li> <li>Represent all entities by hashes (container images, git commits, bl\u043ebs, pull requests etc.);</li> <li>Allow anyone to add some metadata with signature to any entity;</li> <li>Allow anyone to decide whose metadata to trust;</li> <li>Build chain/tree of trust: dependencies can be organized using the same architecture, and containers built</li> </ol>"},{"location":"#instruments-and-utilities","title":"Instruments and utilities","text":"<p>A variety of utility tools to assist with all the aspects of the solution are under active development. Explore the tools available now to get started with GOSH:</p> <ul> <li>create and manage your on-chain repositories using GOSH Web or directly in the Docker Extension</li> <li>work with on-chain repository as if you use a regular git repository with Git Remote Helper</li> <li>To ensure the security of your software supply chain, you can use AnyTree. This is a software deployment system that is secured by the blockchain.</li> </ul>"},{"location":"links/","title":"Links","text":"<p>GOSH website</p> <p>GOSH Web App</p> <p>GOSH Blockchain Explorer</p> <p>GOSH repository</p>"},{"location":"acki-nacki/connection_to_network/","title":"Connection to network","text":""},{"location":"acki-nacki/connection_to_network/#quick-start","title":"Quick Start","text":""},{"location":"acki-nacki/connection_to_network/#guide-overview","title":"Guide overview","text":"<p>This guide will help you get started with such essential Acki Nacki tools as:</p> <ul> <li>TVM-CLI </li> <li>Solidity Compiler </li> <li>Acki Nacki Blockchain Explorer </li> <li>GraphQL API</li> </ul> <p>You will learn how to:</p> <ul> <li>Create and compile your first Solidity contract</li> <li>Deploy your first contract</li> <li>Run it on-chain</li> <li>Run a getter-function</li> <li>Make a transfer</li> <li>Explore contract data in Explorer and GraphQL playground</li> <li>Configure your own giver</li> </ul>"},{"location":"acki-nacki/connection_to_network/#install-tvm-cli","title":"Install TVM-CLI","text":"<p>Download  and install the TVM-CLI for the platform you need from here</p>"},{"location":"acki-nacki/connection_to_network/#create-contract","title":"Create contract","text":"<p>Create file <code>helloWorld.sol</code> with following content:</p> <pre><code>pragma ton-solidity &gt;= 0.35.0;\npragma AbiHeader expire;\n\n// This is class that describes you smart contract.\ncontract helloWorld {\n    // Contract can have an instance variables.\n    // In this example instance variable `timestamp` is used to store the time of `constructor` or `touch`\n    // function call\n    uint32 public timestamp;\n\n    // Contract can have a `constructor` \u2013 function that will be called when contract will be deployed to the blockchain.\n    // In this example constructor adds current time to the instance variable.\n    // All contracts need call tvm.accept(); for succeeded deploy\n    constructor() public {\n        // Check that contract's public key is set\n        require(tvm.pubkey() != 0, 101);\n        // Check that message has signature (msg.pubkey() is not zero) and\n        // message is signed with the owner's private key\n        require(msg.pubkey() == tvm.pubkey(), 102);\n        // The current smart contract agrees to buy some gas to finish the\n        // current transaction. This actions required to process external\n        // messages, which bring no value (hence no gas) with themselves.\n        tvm.accept();\n\n        timestamp = block.timestamp;\n    }\n\n    function renderHelloWorld () public pure returns (string) {\n        return 'helloWorld';\n    }\n\n    // Updates variable `timestamp` with current blockchain time.\n    function touch() external {\n        // Each function that accepts external message must check that\n        // message is correctly signed.\n        require(msg.pubkey() == tvm.pubkey(), 102);\n        // Tells to the TVM that we accept this message.\n        tvm.accept();\n        // Update timestamp\n        timestamp = block.timestamp;\n    }\n\n    function sendValue(address dest, uint128 amount, bool bounce) public view {\n        require(msg.pubkey() == tvm.pubkey(), 102);\n        tvm.accept();\n        // It allows to make a transfer with arbitrary settings\n        dest.transfer(amount, bounce, 0);\n    }\n}\n</code></pre>"},{"location":"acki-nacki/connection_to_network/#install-solidity-compiler","title":"Install Solidity compiler","text":"<p>Download and install the Solidity compiler for required platform from here</p>"},{"location":"acki-nacki/connection_to_network/#compiling","title":"Compiling","text":"<p>Compile the contract using Solidity compiler:</p> <pre><code>sold helloWorld.sol\n</code></pre> <p>The compiler produces <code>helloWorld.code</code>, <code>helloWorld.tvc</code> and <code>helloWorld.abi.json</code> to be used in the following steps.</p> <p>Binary code of your contract is recorded into <code>helloWorld.tvc</code> file.</p>"},{"location":"acki-nacki/connection_to_network/#deploy","title":"Deploy","text":"<p>Let's deploy the contract to Acki Nacki development blockchain at ackinacki-testnet.tvmlabs.dev</p> <p>1) Make sure TVM-CLI is in $PATH:</p> <pre><code>export PATH=$PATH:&lt;PATH_TO&gt;/tvm-cli\n\ntvm-cli config --url ackinacki-testnet.tvmlabs.dev\n</code></pre> <p>2) Generate address, keys and seed phrase for your contract:</p> <pre><code>tvm-cli genaddr helloWorld.tvc --genkey helloWorld.keys.json\n</code></pre> <p>Address of your contract in the blockchain is located after <code>Raw address:</code></p> <p></p> <p>IMPORTANT</p> <p>Save this value - you will need it to deploy your contract and to work with it. We will refer to it as <code>&lt;YourAddress&gt;</code> below.  </p> <p>Seed phrase is also printed to stdout. Key pair will be generated and saved to the file <code>helloWorld.keys.json</code>.</p> <p>3) Get some test-tokens to your account.</p> <p>Note</p> <p>You will need to send some tokens to the address before the actual deployment. Acki Nacki deploy is fee-based, so your new contract will be charged for this. (You will need about 10 tokens to deploy)</p> <p>We recommend creating a Wallet contract that will serve as your giver.</p> <p>To replenish it, please contact us in Channel on Telegram.</p> <p>4) Check the state of the pre-deployed contract. It should be <code>Uninit</code>:</p> <pre><code>tvm-cli account &lt;YourAddress&gt;\n</code></pre> <p>You will see something similar to the following:</p> <p></p> <p>5) Deploy your contract to the early configured network with the following command:</p> <pre><code>tvm-cli deploy --abi helloWorld.abi.json --sign helloWorld.keys.json helloWorld.tvc {}\n</code></pre> <p>Info</p> <p>If there are arguments in the contract constructor, then they must be specified in curly brackets</p> <p></p> <p>6) Check the contract state again. This time, it is should be <code>Active</code>.</p> <p></p>"},{"location":"acki-nacki/connection_to_network/#view-contract-information-with-explorer","title":"View contract information with Explorer","text":"<p>Go to Acki Nacki explorer and search for  in search bar. Open your account page. You will need it later to see its transactions and messages, that we will produce in the next steps. <p></p>"},{"location":"acki-nacki/connection_to_network/#explore-contract-information-with-graphql","title":"Explore contract information with GraphQL","text":"<p>Go to GraphQL playground. Enter in the left pane and click Run button (replace the contract's address with the one you got in the previous steps).</p> <pre><code>query {\n  accounts(\n    filter: {\n      id: {\n        eq: \"&lt;YourAddress&gt;\"\n      }\n    }\n  ) {\n    acc_type_name\n    balance\n    code\n    code_hash\n    data\n  }\n}\n</code></pre> <p>You will see something that looks similar following:</p> <p></p> <p>Info</p> <p>You can specify any other fields in the result section that are available in GraphQL Schema. Click <code>Docs</code> on the right side of your screen to explore it.</p>"},{"location":"acki-nacki/connection_to_network/#run-a-getter-function","title":"Run a getter function","text":"<p>for example, the <code>timestamp</code> method:</p> <p><pre><code>tvm-cli run &lt;YourAddress&gt; timestamp {} --abi helloWorld.abi.json\n</code></pre> result:</p> <p></p>"},{"location":"acki-nacki/connection_to_network/#call-function","title":"Call function","text":"<p>for example, the <code>touch</code> method:</p> <p><pre><code>tvm-cli call &lt;YourAddress&gt; touch {} --abi helloWorld.abi.json --sign helloWorld.keys.json\n</code></pre> result:</p> <p></p>"},{"location":"acki-nacki/connection_to_network/#creating-your-own-giver","title":"Creating your own giver","text":"<p>To create your own giver, deploy (according to the instructions above) any contract of wallet, for example this one:</p> <pre><code>pragma solidity &gt;= 0.6.0;\n\n/// @title Simple wallet\n/// @author Tonlabs\ncontract Wallet {\n    // Modifier that allows function to accept external call only if it was signed\n    // with contract owner's public key.\n    modifier checkOwnerAndAccept {\n        // Check that inbound message was signed with owner's public key.\n        // Runtime function that obtains sender's public key.\n        require(msg.pubkey() == tvm.pubkey(), 100);\n\n        // Runtime function that allows contract to process inbound messages spending\n        // its own resources (it's necessary if contract should process all inbound messages,\n        // not only those that carry value with them).\n        tvm.accept();\n        _;\n    }\n\n    /*\n     * Public functions\n     */\n\n    /// @dev Contract constructor.\n    constructor() public checkOwnerAndAccept { }\n\n    /// @dev Allows to transfer grams to the destination account.\n    /// @param dest Transfer target address.\n    /// @param value Nanograms value to transfer.\n    /// @param bounce Flag that enables bounce message in case of target contract error.\n    function sendTransaction(address payable dest, uint128 value, bool bounce) public view checkOwnerAndAccept {\n        // Runtime function that allows to make a transfer with arbitrary settings.\n        dest.transfer(value, bounce, 3);\n    }\n\n    // Function to receive plain transfers.\n    receive() external payable {\n    }\n}\n</code></pre> <p>Request test tokens from us for this wallet and pay for the deployment of contracts from this wallet in the future</p>"},{"location":"acki-nacki/connection_to_network/#transfer-of-tokens-from-own-giver","title":"Transfer of tokens from own giver","text":"<pre><code>tonos-cli call &lt;walletAddress&gt; sendTransaction '{\"dest\":\"DestAddress\", \"value\":10000000000, \"bounce\":false}' --abi wallet.abi.json --sign wallet.keys.json\n</code></pre> <p>Info</p> <ul> <li>Contracts take value in nanotokens</li> <li>You will need approximately 10 tokens to deploy the contract</li> <li>Bounce = true means that if the recipient does not exist, money will be returned back. If you plan to transfer money for deploy, specify Bounce = false!</li> </ul>"},{"location":"acki-nacki/connection_to_network/#whats-next","title":"What's next?","text":"<p>Congratulations, \u0442ow your contract is up and running! Now, you can get acquainted with:</p> <ul> <li>Solidity API for TVM</li> <li>more contract samples</li> </ul>"},{"location":"acki-nacki/overview/","title":"Overview","text":"<p>watch the event here</p>"},{"location":"acki-nacki/overview/#abstract","title":"Abstract","text":"<p>We propose an asynchronous, highly effective proof-of-stake protocol optimized for fast finality, while allowing for high throughputs via execution parallelization. It is a probabilistic protocol that achieves higher Byzantine fault tolerance than Nakamoto, BFT (including Hotstuff and AptosBFT), Solana, and other modern consensus protocols. Our protocol reaches consensus in two communication steps and has a total number of messages that are subquadratic to the number of nodes, with probabilistic, dynamically adjusted safety guarantees. We trade off deterministic consensus with theoretical constraints on message complexity and the number of Byzantine agreements, with probabilistic algorithms overtaking these boundaries. We further claim that because of the use of randomness and socioeconomics in blockchain designs, no real trade-off is actually present. One of the key ingredients of our approach is separating the verification of execution by a consensus committee from the attestation of block propagation by network participants. Our consensus committee is randomly selected for each block and is not predetermined, while the Leader is deterministic.</p>"},{"location":"acki-nacki/overview/#introduction","title":"Introduction","text":"<p>Current public blockchains are almost exclusively used for financial applications, be it for the store and transfer of value or decentralized finance. Users are ready to pay gas and transaction fees when transacting in value. The primary reason for this user experience inefficiency is the inherent lack of performance in both transaction execution throughput and time to finality, due to strict requirements on state validation. </p> <p>We present a highly efficient, scalable, and practical blockchain protocol optimized for heavy parallelization and extremely fast finality times. The goal of the protocol is to produce performance comparable to cluster cloud databases without compromising security.</p>"},{"location":"acki-nacki/overview/#background","title":"Background","text":"<p>Consensus protocols in computer science are categorized into probabilistic and deterministic. Since 1978, deterministic protocols have evolved, leading to pBFT's creation for varied applications without addressing decentralized money's double spending challenge.</p>"},{"location":"acki-nacki/overview/#bitcoin","title":"Bitcoin","text":"<p>Nakamoto's Bitcoin, introduced on October 31, 2008, first solved double spending with a Proof-of-Work (PoW) probabilistic consensus. Miners compete by solving cryptographic puzzles for block proposal rights, embedding economic incentives into its security. Despite its pioneering role, Bitcoin's low transaction rate (7 transactions per second) and long finalization times limit its functionality beyond a store and transfer of value.</p>"},{"location":"acki-nacki/overview/#bft","title":"BFT","text":"<p>Before Ethereum in 2014, S. King and S. Nadal proposed Proof-of-Stake (PoS) in 2012, enabling deterministic protocols like pBFT in cryptocurrencies by staking assets. This shift allowed enhancements over pBFT, but BFT's deterministic nature is diluted in PoS due to economic variables and probabilistic encryption, aligning its security more with cryptography and game theory despite performance sacrifices.</p>"},{"location":"acki-nacki/overview/#fast-byzantine-paxos","title":"Fast Byzantine Paxos","text":"<p>This protocol, aiming for rapid asynchronous consensus, requires consensus in two steps normally but necessitates &gt;= 5 * f + 1 nodes to manage f Byzantine nodes, a stricter requirement than pBFT. It illustrates the deterministic protocols' limitations in efficiently addressing malicious nodes.</p>"},{"location":"acki-nacki/overview/#modern-blockchains","title":"Modern Blockchains","text":"<p>Recognizing performance problems of Nakamoto and BFT consensus protocols lately few other approaches  surfaced. We will compare with three most performant of them: Solana, Avalanche, Aptos, Algorand and Dfinity.</p>"},{"location":"acki-nacki/overview/#solana","title":"Solana","text":"<p>Solana stands out as a blockchain platform designed for decentralized applications (dApps), focusing on high scalability and efficiency. It boasts a superior transaction processing capability, enabling higher transactions per second (TPS) with lower fees. Solana combines Proof of Stake (PoS) with Proof of History (PoH), a concept introduced by Yakovenko, to verify time passage between events, enhancing consensus efficiency. This approach uses validator clusters instead of individual nodes, though its scientific basis has faced scrutiny.</p>"},{"location":"acki-nacki/overview/#avalanche","title":"Avalanche","text":"<p>The Avalanche consensus mechanism involves nodes conducting repeated voting among a small group of validator nodes to determine transaction acceptance. Validators respond with their preferred transaction, and if a significant majority agrees, that transaction is chosen. Parameters like the threshold for agreement and Confidence Threshold are adjustable. Avalanche subsampling has low message overhead regardless of the number of validators. Transitive voting helps with transaction throughput. Delays can occur when multiple blocks are proposed simultaneously. The attack probability in Avalanche dynamically changes based on input parameters, affecting finalization time and message complexity.</p>"},{"location":"acki-nacki/overview/#aptosbft","title":"AptosBFT","text":"<p>The Aptos builds on advanced pBFT variants like Hotstuff, focusing on random leader selection for each block to improve consensus. However, this necessitates frequent message replication across all network nodes, adding quadratic complexity and impacting overall performance.</p>"},{"location":"acki-nacki/overview/#algorand","title":"Algorand","text":"<p>The Algorand is a strongly synchronous 3-step protocol. Algorand relies on a public randomness computed in previous blocks. It is used to elect a committee of leaders and a committee of block validators at each round that will have a sufficient number of honest nodes with overwhelming probability. The Algorand\u2019s communication steps consist of: gossip propagation of blocks from all network leaders, BFT among the committee of validators, and the final gossip propagation of the block to the network. The Algorand requires more than 2/3 of the nodes in the validator committee to be honest to ensure security guarantees during the execution of the BFT protocol.</p>"},{"location":"acki-nacki/overview/#dfinity","title":"Dfinity","text":"<p>The Dfinity consensus protocol has four layers: client identities, decentralized random beacon, blockchain with leader ranking, and decentralized notary for finality. Security assumption requires a certain ratio of honest to malicious nodes. The consensus process involves 4 steps with different latencies based on adversary types. In the original paper, the message complexity is unbounded. However, the proposed modification reduces  the expected communication complexities against an adaptive adversary, and against a static or mildly adaptive adversary</p>"},{"location":"acki-nacki/overview/#sharding","title":"Sharding","text":"<p>The Sharding a method aimed at boosting performance through data and execution partitioning, was pioneered by Ziliqa and further developed in Ethereum for state sharding. Protocols like TON, Near, and Elrond also employ sharding with parallel leader selection and state synchronization to enhance throughput. Despite these advancements, sharding and parallel execution technologies have yet to surpass a practical limit of around 100K TPS in controlled tests, indicating persistent scalability challenges in blockchain consensus mechanisms.</p>"},{"location":"acki-nacki/overview/#construction-of-acki-nacki","title":"Construction of Acki Nacki","text":"<p>The Acki Nacki probabilistic consensus protocol intends to take the performance of fault-tolerant consensus protocols as far as we can. In Acki Nacki, participants can perform three roles: Block Producer, Block Keeper and Verifier (which we call the Acki-Nacki entity). All of these roles could be performed by any network participant in parallel. So many Acki Nacki chains (called Threads) can exist simultaneously, but since their security and functionality do not depend on each other</p>"},{"location":"acki-nacki/overview/#definitions","title":"Definitions","text":"<p>Account (contract) is a record in a distributed database.</p> <p>Thread is a subset of nodes that serves a particular subset of Accounts.</p> <p>Block is an object that contains new transactions which, once finalized, are stored in the blockchain as a permanent and immutable part of this decentralized ledger. Each block includes information such as transaction data, timestamp, common section, and a reference to the previous block, creating a chain of interconnected blocks.</p> <p>Common section is the section of the block that contains information that needs to be shared among all network participants. </p> <p>Block Producer (BP) is a leader of a particular Thread responsible for block production.</p> <p>Block Keeper (BK) is an entity having two functions:  Receives blocks from BP and sends out an Attestation with block hash and other metadata back to BP. BK does not check block transactions validity, it does not try to execute the block, only apply it to its local state with a mark 'Not Final'. Performs a self check if it needs to become a Verifier for this block as described below. If it does, BK will verify the Block and broadcast the result: Ack, if the Block is ok and Nack, if the block is invalid.</p> <p>Verifier (Acki-Nacki) \u2014 is a BK being responsible for block validation and notifying all network participants about his verdict: is block valid or not.</p> <p>Attestation \u2014 message that is sent to BP by any BK after receiving the block. Attestation is BLS signature done on BK\u2019s private key. BP of the next block must aggregate all received Attestations for the previous block into one BLS signature and include it into the Common section of the new block.</p> <p>Ack \u2014 Verifier\u2019s message that is broadcasted to all network participants by Acki-Nacki if the block is verified and it\u2019s valid. </p> <p>Nack \u2014 Verifier\u2019s message that is broadcasted to all network participants by Acki-Nacki if the block is verified and it\u2019s NOT valid.</p> <p>Attestations and Verifier\u2019s messages must contain block hash, its BLS signature on BK\u2019s private key. Some extra data may be added. For example, Nack contains the reason for block rejection.</p>"},{"location":"acki-nacki/overview/#security-assumptions","title":"Security Assumptions","text":"<p>We follow standard assumptions of Safety and Liveness properties for Acki Nacki protocol. These properties make the network operation look like the operation of a monolithic valid server i.e. linearizable consistent block ledger. Safety: there are no two honest BK accepting different blocks of the same height and no block with an incorrect transaction is being finalized Liveness: If an honest BP has received a transaction then it will be eventually included in every honest node\u2019s ledger.</p> <p>In accordance with these properties, we classify the attacks violating them:</p>"},{"location":"acki-nacki/overview/#safety-attacks","title":"Safety attacks","text":"<p>Such attacks include dissemblance and private chain attacks. Dissemblance means that the adversary maintains Byzantine nodes to send different messages to different nodes, which may lead to nodes\u2019 disagreement. Private chain attacks mean that the adversary controls Byzantine nodes to work on a separate blockchain privately while following the protocol. </p>"},{"location":"acki-nacki/overview/#liveness-attacks","title":"Liveness attacks","text":"<p>Liveness attacks. These types of attacks include the aforementioned dissemblance and withholding attacks. Apart from safety, dissemblance may retain honest nodes to make decisions forever, breaking the liveness. Retaining means that the adversary which controls Byzantine nodes doesn't send messages to particular nodes, which may also retain them to make decisions forever.</p>"},{"location":"acki-nacki/overview/#block-producer-selection","title":"Block Producer selection","text":"<p>In Acki-Nacki, the selection of Block Producers (BPs) is not random due to security concerns regarding potentially malicious BPs. Instead, a deterministic algorithm is used where the hash of a block with a shard split or other message serves as a seed for random sampling of one BP from a sorted list of BPs' public keys. The current list of BPs is always included in the Common Section of any Block, which also contains other block-related data such as Attestations, Verifier's messages, slashing/reward conditions, etc.</p>"},{"location":"acki-nacki/overview/#acki-nacki-selection-algorithm","title":"Acki-Nacki Selection Algorithm","text":"<p>The Acki-Nacki selection algorithm in the Acki Nacki blockchain involves calculating a value based on the block and the BP's secret key, then determining if it meets certain criteria to be considered Acki-Nacki. The process ensures randomness in selecting Acki-Nacki BPs, with each selection being an independent event. This method allows for control over the average number of Acki-Nacki per block.</p>"},{"location":"acki-nacki/overview/#the-new-block-production-and-broadcast","title":"The new block production and broadcast","text":"<p>In the new block production and broadcast process, a Block Producer (BP) releases a new block every 330 milliseconds by collecting unprocessed messages, executing transactions, and creating a block within certain limits. The BP signs the block with its BLS private key and broadcasts it to all Block Keepers (BKs). Upon receiving the block, a BK  computes an Attestation for the block, and sends it back to the BP.</p>"},{"location":"acki-nacki/overview/#the-block-verification","title":"The block verification","text":"<p>Block verification in the protocol is conducted by Acki-Nacki entities selected through an algorithm. These entities must validate blocks and send Ack/Nack messages to the network to avoid being slashed. Third parties can also validate blocks with a bond but are not obligated to do so. If a Block Producer (BP) creates a block with complex execution, Acki-Nacki may delay verification which may lead to  incorrect transactions being accepted. To counter this safety attack, Verifiers will stop after 330 ms and send a special Nack with a \"too complex\" message, allowing the committee to penalize the BP if necessary.</p>"},{"location":"acki-nacki/overview/#acki-nacki-selection-proof","title":"Acki-Nacki Selection Proof","text":"<p>In the Acki-Nacki selection proof process, a Block Keeper (BK) generates BLS key pairs sorted by sequential number for block verification. The BK commits the hash of each key pair to the network using a Merkle Tree. After each block, the Acki-Nacki BK reveals a private key, SeqNo, and Merkle Proof in the Verification message. Other BKs must also reveal their private keys eventually. Failure to send Verifications or provide keys accurately results in it being slashed.</p>"},{"location":"acki-nacki/overview/#proof-of-stake-and-fork-choice-rule","title":"Proof-of-Stake and Fork Choice rule","text":"<p>A Fork Choice Rule algorithm based on stake weight to resolve situations where two valid blocks exist at the same height. The algorithm determines which block to finalize by considering attestations and stake amounts. Participants are required to attest to only one block at a certain height, with penalties for attesting to multiple blocks. The protocol involves executing the Acki-Nacki Selection Algorithm for blocks with a certain number of attestations or the highest stake amount. After applying the Fork Choice Rule, the BK sends to other BKs either the block with Attestations or the block with Attestations and Ack/Nack, depending on whether they became Acki-Nacki for that block.</p>"},{"location":"acki-nacki/overview/#the-block-finalization","title":"The block finalization","text":"<p>The process of block finalization involves each BK receiving a new block, updating the state, and marking mutations as not final until receiving Attestations from BP in the Common section of subsequent blocks to meet the minimum Attestation Threshold specified in the network configuration.  The BK also waits a specified time for block to finalize after collecting the required number of block Attestations. If no negative acknowledgments (Nack) are received within the time frame, the block is marked as final. If there are insufficient block attestations, the block remains unfinalized, prompting network participants to decide on potential actions such as allowing ongoing unfinalized block production, halting the network after a set number of blocks, or considering penalties for BKs failing to provide attestations.</p>"},{"location":"acki-nacki/overview/#joint-committee","title":"Joint Committee","text":"<p>In the event of a Nack, multiple Attestations on the same block by one Block Keeper (BK), or other malicious actions, the Joint Committee function is invoked. Each BK is requested to vote for slashing malicious BKs, Block Producers (BPs), or rejecting a malicious block. The network requires as many votes, as determined by network participants, to confirm malicious activity and take appropriate actions.</p>"},{"location":"acki-nacki/overview/#slashing","title":"Slashing","text":"<p>The slashing conditions will lead network participants to either lose their stake entirely, or by some factor (bleeding). When we say \u201close\u201d we mean that the stake will be burned and not transferred to some other honest party.  There are various scenarios where slashing can occur, such as when participants fail to perform certain tasks or behave in a non-compliant manner.</p>"},{"location":"acki-nacki/overview/#dynamically-adjustable-parameters","title":"Dynamically adjustable parameters","text":"<p>One of the main advantages of the Acki Nacki consensus protocol is presence of several dynamically adjustable parameters such as the number of Attestations needed for block finalization, the average expected number of Acki-Nacki per block, the number of votes for Join Committee and the probability of a successful attack with a certain percentage of malicious BKs. All these parameters can be changed by network participants through voting according to their preferences.</p> <p>For example, one can input the number of BKs, the desired attack probability with a certain number of malicious BKs. Acki Nacki will then automatically adjust the parameters of the number of Attestations and the number of Acki-Nacki so that the network achieves the highest throughput with the shortest finality.</p>"},{"location":"acki-nacki/overview/#attacks-analysis","title":"Attacks analysis","text":"<p>In the analysis of attacks, you have the opportunity to conduct experiments with parameters using the following link.  </p> <p>Here you can create graphs illustrating the relationship between the probability of a successful attack and the number of Acki-Nacki, comparision the Acki Nacki consensus with the Nacamoto consensus and the BFT consensus, and build a graphs of the Acki-Nacki Consensus input parameters</p>"},{"location":"acki-nacki/overview/#performance-analysis","title":"Performance analysis","text":"<p>Without taking state sharding into account the limitation to performance in Acki Nacki network is down to the two factors: the number of blocks a BK can receive over the network and apply and the number of blocks all network Verifiers can process at any given moment. This performance is entirely dependent on computer and network resources committed by Participants, number of BKs and expected number of Acki-Nacki per block. </p> <p>With sharded design there is no theoretical limit to the Acki Nacki network throughput. Without sharded design, taking into account modern computer hardware and datacenter Internet connection we calculate a practical limit of 250,000 transactions per second of a minimal 500 byte messages with less than a 1 sec finality. With sharding enabled the protocol can scale to millions of transactions of any complexity just by adding computing resources which makes it comparable with centralized cloud services. </p> <p>Acki Nacki achieves this performance as a result of vastly reduced message complexity during most of its operation time.</p> <p>The Acki Nacki algorithm achieves consensus in two communication steps. The first step involves sending the block from BP to BKs. The second step involves sending of Ack/Nacks by Acki-Nacki to all BKs, in parallel with the sending of attestations from BKs to BP.</p> <p>In total the following messages are sent: The block sent from BP to BKs, the Attestations sent from BKs to BP and the Ack/Nack messages sent from several chosen Acki-Nacki to BKs. Here the positivistic scenario ends. The Nack message and accidental Forks will trigger more messages, but the Nack message is highly improbable and Forks are rare events.</p>"},{"location":"ethereum-L2/overview/","title":"Overview","text":"<p>GOSH is an asynchronous, highly scalable validity rollup that enables any asset on the Ethereum blockchain to be transferred into GOSH and vice versa. All ZK Proofs (Zero-knowledge proofs) are prepared on the user side by a Proposer. It is then submitted to the Independent Collator which receives user input and executes them on GOSH.</p> <p>Anyone can submit a resulting L2 (GOSH Blockchain) state root to L1 (Ethereum Blockchain). Randomly selected Verifiers run the state transition periodically and slash Collators in case of fraud via decision by L1. Verifiers are slashed for false fraud alerts. If Collator is censoring users' transactions, it is possible to force the transaction via L1.  Anyone can publish L2 state root but only Collator can propose L2 state change.</p> <p>Proof Summary</p> What do we Prove How do we Prove it <code>L1 Blocks are correct</code> BLS Signatures check <code>L2 Blocks are correct</code> Validator signatures + Verifiers Fraud Proofs <code>L1 transaction are within the correct blocks</code> Merkle tree proof from Transaction hash to L1 block hash <code>L2 transaction are within the correct blocks</code> Merkle tree proof from Transaction hash to L2 block hash <code>All L1 transactions are provided to L2 from block A to block B</code> Txn count in block a and Txn count in block B are known we can verify that total transaction count transferred to GLOCK is correct and since we have hashes it's impossible to cheat <code>Transaction counts and Balances are correct for L1 Block transmitted to L2</code> Merkle tree of account states for a particular L1 block <code>All L2 Withdrawal Transactions are transferred to L1   from Block A to Block B</code> Txn count in block a and Txn count in block B are known we can verify that total transaction count transferred to ELOCK is correct and since we have hashes it's impossible to cheat <code>TIP-3 Deposit/Transfer/Withdrawal Transaction  Execution is correct</code> ZKP for TIP-3 Circuit <code>Validator set change from last KeyBlock is correct</code> ZKP for Elector contract Circuit <code>Validators Fraud Proofs</code> Fraud detection mechanism by Verifiers"},{"location":"ethereum-L2/overview/#roadmap","title":"Roadmap","text":""},{"location":"ethereum-L2/overview/#stage-1-trustless-bridge-in-production","title":"Stage 1: Trustless Bridge   (In production)","text":"<p>Challenges:</p> <ul> <li>L1 can\u2019t have the L2 entire state (L2 state is too large)</li> <li>There must be a mechanism to move funds from L2 even if: L2 is not moving; L2 has banned specific accounts</li> <li>EVM and TVM are different. TVM is a reference VM for the L2 chain. This means that even if L1 has a state it can\u2019t execute transactions to verify correctness. But it can execute ZKP which will prove the correctness of operations in the particular circuit</li> </ul> <p>Info</p> <p>At this stage we assume: L2 fully trusts L1, it knows Validators (Committee) PubKeys and can always validate the chain of L1 blocks. We do not validate the smart contract execution on L2. We protect against any malicious 3rd party except for L1 and L2 Validators.</p> <p>As an example, we will talk about ETH moving from the Ethereum mainnet into WETH Asset on GOSH L2 Blockchain and back. In general, any asset on Ethereum can be supported with necessary adjustments made to ELOCK smart contract Deposit/Withdrawal functions. Since GOSH uses ed25519 we use a double signature envelope scheme to prove signatures on GOSH to ELOCK Smart Contract on Ethereum (we could use ZKP to prove the ed25519 or a precompile proposed EIP665 whenever either of those solutions will be production ready).</p> <p>Info</p> <p>What we don\u2019t cover at this Stage? </p> <ul> <li>L2 contract execution is not validated (no validity or fraud proofs)  </li> <li>Funds retrieval function in case of L2 censored / stopped  </li> <li>L1 Funds retrieval is complicated and expansive  </li> </ul>"},{"location":"ethereum-L2/overview/#stage-2-optimistic-roll-up","title":"Stage 2: Optimistic roll-up","text":"<p>Info</p> <p>At this stage we add fraud and execution proofs for TIP-3 contracts.</p> <p>The Proposer constructs the TIP-3 execution proof and sends it together with block proofs. If the execution is correctly proved the funds can be withdrawn immediately. If the Proposer does not wish to pay the gas fees for ZKP execution it can supply the withdrawal request without any proof but with a bond. In which case the withholding period will be activated (hence optimistic rollup). Another Proposer can verify the correctness of execution of the TIP-3 in the proposed batch and if found incorrect execution can supply the fraud proof (consisting of proof of the correct execution of the corrupted TIP-3 transaction and proof of block tree hashes which will be incompatible with hashes provided by the first Proposer) and collect the Proposer Bond.</p> <p>At this stage we have added a mechanism of Fraud proof of L2 validators making the network effectively on par with security assumptions of other optimistic rollups, but also providing a mechanism for immediate Validation of token contract execution on L2 network.</p> <p>Info</p> <p>What we don\u2019t cover at this Stage? </p> <ul> <li>Funds retrieval function in case of L2 censored/stopped  </li> <li>L1 funds retrieval is complicated and expansive in case of immediate withdrawal  </li> </ul>"},{"location":"ethereum-L2/overview/#stage-3-validium-zkp-roll-up","title":"Stage 3: Validium ZKP roll-up","text":"<p>At this stage, we are adding external Verifiers and putting a bond of L2 Collators on the Ethereum mainnet. Verifiers will be able to supply fraud proofs as well as data availability proofs.</p> <p>The Verifiers can slash the L2 Collators in case of misbehavior by supplying ZKPs proving the wrong block production, or by successfully challenging data availability proofs making it effectively an Ethereum Sharding design since GOSH is a multithreaded, multisharded blockchain.</p> <p>Important</p> <p>At this stage, there is no need to trust L2 Collators with anything. L1 can verify all L2 state transitions and L2 can verify L1 contract state transitions. Funds are easily withdrawn from either blockchain. To break the system both L1 and L2 need to be corrupted or stopped simultaneously.</p>"},{"location":"ethereum-L2/overview/#contracts","title":"Contracts","text":"<ul> <li> <p>ELOCK \u2014 is a GOSH L2 smart contract on Ethereum Blockchain. It receives deposits from users, manages withdrawals, and locks user funds. ELOCK also counts its total balance, and total transaction count and stores root Merkle proofs, withdrawal smart contract code hash, etc. for L2 synchronization.</p> </li> <li> <p>GLOCK \u2014 is a set \u043ef special contracts on GOSH Blockchain. Aside from managing TIP-3 distributed tokens they also manage the deposits and withdrawals assets of users. Contract <code>Checker.sol</code> receives an external message from <code>Proposer</code> with Ethereum blockchain proofs signed by the Ethereum Committee, checks the hash of the blocks lined up in the chain, and deploys the contract <code>Proposal.sol</code> that validators check and vote for the Ethereum blocks in GOSH then receives a list of verified transactions and send a message to the root contract <code>RootTokenContract.cpp</code></p> </li> <li> <p>RootTokenContract - is a smart contract on GOSH that manages user withdrawals. It receives TIP-3 transactions, verifies them and adds transactions to the counter index. Also it deploys the contract TIP-3 wallet contract (<code>TONTokenWallet.cpp</code>) and sends wrapped tokens there.</p> </li> <li> <p>TONTokenWallet - is a custom TIP-3 contract that runs in GOSH Masterchain and in addition to standard functions has <code>burnTokens</code> method. It is called when WETH needs to be transferred to Ethereum Blockchain. Burn is proven to ELOCK contract in order to allow for ETH native token withdrawals. </p> </li> </ul>"},{"location":"ethereum-L2/overview/#commission","title":"Commission","text":""},{"location":"ethereum-L2/overview/#for-deposit-to-gosh","title":"for deposit to GOSH","text":"<p>When transferring assets to GOSH, <code>checker.sol</code> sends the transfer amount and coefficients <code>a</code> and <code>b</code> to the <code>RootTokenContract.cpp</code> and it calculates the commission amount. Then mints the wrapped tokens to the user TIP-3 wallet minus the commission. And the commission is sent to the wallet by the commission in GOSH.</p> <p>calculated as:</p> <p>\\(\\frac{a * x}{10 000} + b\\)</p> <p>where:</p> <p>a  - commission percentage = 10 (0.1%)</p> <p>b - permanent commission (does not depend on the transfer amount, now = 0)</p> <p>\u0445 - amount of tokens to transfer</p>"},{"location":"ethereum-L2/overview/#for-withdraw-to-ethereum","title":"for withdraw to Ethereum","text":"<p>The commission is calculated in the ELOCK contract.</p> <p>It consists of 2 parts:</p> <ul> <li>Part 1 - the cost of the transaction for the transfer of <code>WETH</code> to the recipient</li> </ul> <p>calculated as: </p> <p>$ 21000 * gasprice$</p> <p>where:</p> <p>gasprice - gas price during withdraw transaction</p> <ul> <li>Part 2</li> </ul> <p>calculated as: </p> <p>amount of validators' expenses / quantity of transfers to withdraw <code>WETH</code> in the current proposal</p> <p>Then it is sent to the commission wallet.</p>"},{"location":"ethereum-L2/overview/#integration-with-gosh-l2","title":"Integration with GOSH L2","text":"<p>More information about integration with GOSH L2 can be found here</p>"},{"location":"ethereum-L2/overview/#definitions","title":"Definitions","text":"<p>TVM is a Custom Virtual Machine GOSH Blockchain uses. For the GOSH L2 release we use extended TVM with additional instructions, thus TVM smart contract can run Signature Verifications and Calculate Hash functions from Ethereum Data.</p> <p>Masterchain is the (-1) work chain of the GOSH blockchain. It is needed for service contracts and validator contracts.</p> <p>Shardchain is shards into which the workchain is split depending on the network load. When it increases, shards split and when they decrease they merge.</p> <p>Proposer is an off-chain program that any user can run on their machine. It packages all necessary data to prove to the GOSH chain that a particular transaction (let\u2019s call them \u201cL2 transactions\u201d) on the Ethereum Network took place and vice versa \u2014 to prove to Ethereum ELOCK smart contract (i.e. Ethereum validators) that an L2 transaction took place on the GOSH Blockchain.</p> <p>Proposer will always accumulate all transactions that are currently not applied to generate the proof, thus ensuring that all transactions of the opposite network are applied. If that is not the case the State Validation function will fail.</p> <p>TIP-3 is a distributed token smart contract standard on the GOSH blockchain. It is a formally verified scalable token design for sharded architecture optimized for parallelization.</p>"},{"location":"ethereum-L2/overview/#added-new-tvm-opcodes","title":"Added new TVM opcodes","text":"<p>KECCAK256 - implements the <code>keccak256</code> hashing algorithm for the data provided in the TVM cell</p> <p>VERGRTH16 - verify <code>Groth16 zk-SNARK</code> proof</p>"},{"location":"ethereum-L2/user-guide/","title":"User Guide","text":"<p>Any DAO on GOSH can become Ethereum Layer 2 with a click of a button.</p> <p>Info</p> <p>This is only possible in the GOSH version of at least 6.1.0</p>"},{"location":"ethereum-L2/user-guide/#deposit-eth-to-gosh","title":"Deposit ETH to GOSH","text":"<p>To make a transfer between wallets, go to the Ethereum tab:</p> <p></p> <p>or select this section by clicking on your profile in the right corner:</p> <p></p> <p>Now we can test the ETH transfer in the alpha version.</p> <p>Click on:</p> <p></p> <p>the \"Cross-chain transfer\" page will open for you.</p> <p>In the Accounts section, click Connect to log into a software cryptocurrency wallet MetaMask</p> <p></p> <p>Enter the amount you want to send</p> <p>Note</p> <p>The amount must be greater than or equal to 0.01</p> <p>Warning</p> <p>The contract has not been formally verified yet. Please do not send a lot!</p> <p></p> <p>Enter the wallet address or GOSH username of the recipient for the transfer. The Amount field will indicate the transferred amount (minus the commission) that will be credited to the recipient's wallet in GOSH.</p> <p></p> <p>After depositing the GOSH contract on Ethereum, you will receive the corresponding amount of WETH tokens (Wrapper Ethereum tokens) in your GOSH network wallet.</p> <p></p>"},{"location":"ethereum-L2/user-guide/#withdraw-wrapped-eth-to-ethereum","title":"Withdraw wrapped ETH to Ethereum","text":"<p>To withdraw tokens from GOSH to Ethereum, go to the Ethereum tab on the DAO page</p> <p></p> <p>or select this section by clicking on your profile in the right corner:</p> <p></p> <p>the \"Cross-chain transfer\" page will open for you:</p> <p></p> <p>In the Accounts section, click Connect to log into a software cryptocurrency wallet MetaMask</p> <p></p> <p>Info</p> <p>In the future, the balances of your wallets on GOSH and Ethereum will be displayed here</p> <p>In the From section, select the GOSH blockchain and enter the sender's wallet address or GOSH username along with the amount of WETH tokens you wish to withdraw:</p> <p></p> <p>In the To section, make sure to choose the Ethereum blockchain network and verify the Receiver's wallet address for accuracy before proceeding. The <code>ETH</code> amount will be automatically calculated.</p> <p></p> <p>Please click on the Next button to proceed.</p> <p>On the right, in the Summary section, you can see information about the amount of assets received and sent.</p> <p></p> <p>The amount of the expected commission for the transfer and and the time before the withdrawal of assets is also indicated</p> <p>Info</p> <p>Tokens are withdrawn every 3 hours</p> <p>Please wait until the process of sending <code>WETH</code> tokens and receiving <code>ETH</code> fully completed</p> <p></p>"},{"location":"ethereum-L2/user-guide/#deposit-erc20-to-gosh","title":"Deposit ERC20 to GOSH","text":"<p>To make a transfer <code>ERC20</code> tokens, go to the Ethereum tab:</p> <p></p> <p>or select this section by clicking on your profile in the right corner:</p> <p></p> <p>Click on:</p> <p></p> <p>the Cross-chain transfer page will open for you.</p> <p>Let's look at the token transfer using the example of the USDC.</p> <p>In the From section, select the token to transfer to GOSH</p> <p></p> <p>To log into a software cryptocurrency wallet MetaMask, you can either click on Connect wallet or go to the Accounts section and click on Connect.</p> <p></p> <p>Enter the amount you want to send</p> <p>Note</p> <p>The amount must be greater than or equal to 0.011</p> <p></p> <p>Enter the wallet address or GOSH username of the recipient for the transfer.</p> <p>The Amount field will indicate the transferred amount (minus the commission) that will be credited to the recipient's wallet in GOSH.</p> <p>The Summary section will display detailed information about the transfer</p> <p></p> <p></p> <p>And click Next button</p> <p>The transfer process has three sub-steps. The first one is to approve tokens, followed by deposit tokens, and finally, waiting for the transfer to be completed.  </p> <p>Once you click on the <code>Approve</code> button, you'll be authorizing the ELOCK contract to initiate the transfer of the specified amount. </p> <p></p> <p>In the opened MetaMask window, confirm the necessary parameters for the transfer.</p> <p></p> <p></p> <p>Click on the Deposit button and then check and confirm the transfer parameters in your MetaMask wallet. </p> <p></p> <p>It's important to ensure that the transfer is being made to the ELOCK contract at this step.</p> <p>address of the ELOCK contract in Ethereum:</p> <pre><code>0x54a858bBD5968Eb755e54C45a3fe5B002bE3c254\n</code></pre> <p></p> <p>After that, you just need to wait for the transfer to be completed.</p> <p></p> <p>After successful completion of the transfer, you will see a confirmation:</p> <p></p> <p>If you want to view your asset balance, you can find it in the Accounts section. To do this select the relevant token in the \"From\" tab.</p> <p> </p>"},{"location":"ethereum-L2/user-guide/#withdraw-erc20-to-ethereum","title":"Withdraw ERC20 to Ethereum","text":"<p>To withdraw ERC20 tokens from GOSH to Ethereum, go to the Ethereum tab on the DAO page and log into a software cryptocurrency wallet MetaMask</p> <p></p> <p>In the From section, select the asset that you want to withdraw to Ethereum</p> <p></p> <p>The available assets will be displayed in the Accounts section</p> <p></p> <p>Enter the desired number of tokens to withdraw</p> <p></p> <p>The Summary section will display detailed information about the withdraw</p> <p>Info</p> <p>Tokens are withdrawn every 3 hours</p> <p></p> <p>In the To section, in the Recipient field, you must specify the recipient's Ethereum wallet address. The number of tokens will be calculated automatically.</p> <p>Please click on the Next button to proceed.</p> <p></p> <p>The transfer of the ERC20 tokens from GOSH to Ethereum will take some time.</p> <p>After the transfer process, you will be able to view the list of your assets that have been transferred from GOSH to Ethereum in the Your pending withdrawals section. These assets are now located in Ethereum on the balance ELOCK contract, and you can withdraw them to your wallets by clicking on the Withdraw button.</p> <p></p> <p>Confirm the withdrawal of tokens to your wallet</p> <p></p> <p>Wait for the tokens to arrive on the balance of your Ethereum wallet</p> <p></p>"},{"location":"hacks-and-grants/overview/","title":"Overview","text":"<p>The \"Hacks &amp; Grants\" is the new tool integrated into DAOs on GOSH which allows any DAO to create its own Hackathon or Grant Program of any size directly from their decentralized repository</p> <p>Hacks &amp; Grants will soon include an automated reward system that allows users to adapt their Hacks &amp; Grants program to any format, be it dollars, euros, pounds, bitcoins, ether, ERC-20 or DAO tokens(supported). Users can also invite different sponsors to their Hackathon. Planned in the Hacks &amp; Grant program supports multi-token reward pools</p> <p>All code, files, and results stored in decentralized open source code repositories, meaning all Hackathon rules are automatically enforced on-chain, and in a trustless environment</p> <p>Grants on GOSH allow collaborative problem-solving events to be financed, and so sustained, for a longer period of time (coming soon)</p>"},{"location":"hacks-and-grants/user-guide/","title":"User Guide","text":""},{"location":"hacks-and-grants/user-guide/#hackathon","title":"Hackathon","text":""},{"location":"hacks-and-grants/user-guide/#for-the-organizers","title":"for the organizers","text":"<p>important</p> <ul> <li> <p>To create a Hackathon, you must be a member of the DAO.</p> </li> <li> <p>The DAO must have enough tokens in its reserve to allocate towards Hackathon rewards.</p> </li> <li> <p>The experts who will be part of the jury for the Hackathon must be registered participants of the DAO before the event commences.</p> </li> </ul> <p>To create a Hackathon, you need to navigate to the \"Hacks &amp; Grants\" tab in the DAO where you are a member.</p> <p>Make sure to check the guidelines and requirements of the DAO to ensure that you have the necessary permissions and resources to host the Hackathon.</p> <p></p> <p>and click Create new or start typing the name of the your Hackathon</p> <p></p> <p>then click New hackaton</p> <p>On the page that opens, enter all the necessary  information about the event:</p> <ul> <li>In the README section tell the about your program. What are its aims? Who should participate? How will it work?</li> </ul> <p></p> <ul> <li>In the RULES section, describe the rules that the participants should follow. What is expected, allowed and strictly prohibited?</li> </ul> <p></p> <ul> <li>In the PRIZES section, it is important to outline of the awards will be distributed among the participants. Additionally, it is crucial to explain the evaluation criteria used to determine the winners.</li> </ul> <p>Also here you have the opportunity to provide detailed information about any additional prizes that will be available to participants. This can be a great way to encourage engagement and encourage people to participate in your event or program.</p> <p></p> <p>Info</p> <p>It is not mandatory to provide information in the README, RULES, and PRICES sections, but including them can greatly improve the clarity and informativeness of your content. Therefore, we recommend filling them out whenever possible.</p> <ul> <li>Also, the information about the awards must be configured in the Prize pool section by clicking on the \"Add prize pool\" button.</li> </ul> <p></p> <p>Enter the total amount of the prize pool and distribute it among the prize places.</p> <p>Then click Save distribution</p> <p>Warning</p> <p>The total amount of the prize fund cannot exceed the amount of the DAO reserve balance.</p> <p></p> <p>To make any changes, simply click on the \"Update prize pool\" button.</p> <p></p> <ul> <li>Don't forget to fill in the Short Description section. This information will be visible in the proposal for voting on the creation of the Hackathon after all the necessary data has been filled about the event.</li> </ul> <p></p> <ul> <li>You will need to set the date and time for three important stages. Do this by clicking on the Add date button</li> </ul> <p></p> <p>and in the window that opens, configure on 3 tabs:</p> <p>Start tab - here you need to set the start date and time of the Hackathon.</p> <p>Voting tab - here you need to set the date and time when the acceptance of applications ends, and when they will be presented to the jury members for voting.</p> <p>Warning</p> <p>After the start of the voting stage, it will be impossible to add new participants.</p> <p>Finish tab - you need to set the date and time when the voting stage ends and the winners will be determined. Then click Apply dates</p> <p></p> <p>In the Export tags section, select all the necessary scope for which expert assessments are required.</p> <p></p> <p>Once you've set the dates and times, you can click on Create proposal to publish</p> <p></p> <p>The preparation of the Hackathon repository and the creation of a proposal for its creation will begin.</p> <p>And once it's done, you will be redirected to the DAO events page. </p> <p></p> <p>Once the voting process is completed with a positive outcome, a Hackathon will be created.</p> <p></p> <p>important</p> <p>After the Hackathon is created, its data can be changed and any alterations are subject to voting for approval.</p> <p></p> <p>To be aware of the status of the Hackathon, the time remaining until the next stage will be displayed on its page.</p> <p></p> <p>When the application acceptance stage comes to an end, the <code>Voting</code> stage will begin.</p> <p></p> <p>At the end of the <code>Voting</code> stage, the summing up will start, and the Hackathon will be marked as <code>Finished</code></p> <p></p>"},{"location":"hacks-and-grants/user-guide/#for-participants","title":"for participants","text":"<p>If you're a GOSH user who is interested in participating in a Hackathon, you'll need to visit the Hackathon organizer's DAO. Once there, you can navigate to the \"Hacks and Grants\" tab to learn more about the available Hackathons and select the one that interests you.</p> <p>On the Hackathon page you will find all the necessary information, including a detailed description of the Hackathon, its rules and prizes that can be obtained.</p> <p>If you're not a GOSH user but want to participate in the Hackathon, you'll need to create an GOSH account first. Then you can visit the Hackathon page to get started.</p> <p>During the Hackathon, all participants must complete certain tasks and then upload them to their repositories into their DAO.</p> <p>To participate in the \u041dackathon, you'll need to click on the Add application button.</p> <p></p> <p>If you followed the direct link to the Hackathon</p> <p>then be sure to log into your account by clicking on the Sign in button.  </p> <p> </p> <p>After you entered your passphrase and PIN code on the Hackathon page, the next step is to click on the Add application button.</p> <p>Then, in the form that opens, click Add application form DAO</p> <p></p> <p>and enter the name of your DAO and the name of the repository that you require.</p> <p>Important</p> <ul> <li> <p>You can add an application only from the DAO of which you are a member.</p> </li> <li> <p>Also, keep in mind that each repository is a separate participant of the Hackathon.</p> </li> </ul> <p>Info</p> <p>You can add multiple repositories from one DAO at once by separating the input with a space.</p> <p>Once you have added all the necessary applications, click on \"Submit applications\".</p> <p></p> <p>At the end of the process, all the repositories you have uploaded will be displayed in the \"Your applications\" section.  </p> <p></p> <p>Additionally, you can view information about the other participants of the Hackathon in the \"Participants\" section.</p> <p></p> <p>To keep participants updated on the status of the competition, the remaining time until the next stage will be displayed on the Hackathon page.</p> <p></p> <p>When the application acceptance stage comes to an end, the <code>Voting</code> stage will begin.</p> <p></p> <p>At the end of the <code>Voting</code> stage, the summing up will start, and the Hackathon will be marked as <code>Finished</code></p> <p></p>"},{"location":"hacks-and-grants/user-guide/#expert-tags","title":"Expert Tags","text":"<p>Expert Tags are created as evidence of the member's expertise and experience within this DAO.  </p> <p>By creating and attaching Tags to DAO members, you can count on their skills and experience to help other members of the DAO.</p> <p>Tags affect the number of votes that the expert will be able to use when voting.</p> <p>Info</p> <p>If a DAO member has an attached Expert Tag, then when voting, he will be able to use tokens within his Karma, increased by the coefficient specified when creating this Tag.</p> <p>Tags will make it easier to find a performer to complete a Task or review it.</p> <p>Using expert tags when judging at Hackathons will allow you to take into account the weight of each expert's vote when voting for projects, which reduces the likelihood of a subjective impact of each expert's assessment on the final result and reduces the possibility of manipulation by the jury, i.e. judging will be more objective and independent of each other.</p> <p>If you want to add expert Tags to your DAO simply go to the Settings tab in the karma Tags section and enter the name of the Tag in the appropriate field. </p> <p>You can also specify the percentage by which the karma of the relevant expert will be increased when voting. It's important to note that the experts of the jury must be participants of the DAO before the Hackathon begins.</p> <p>To delete a Tag, click on the cross in the corresponding line.</p> <p>The addition of expert Tags can only be made possible through the voting of the DAO members. Therefore, you must leave a comment for the proposal and then click on the Save changes and create proposal button to initiate the process.</p> <p></p> <p>You will redirected to the event page in the DAO tab. Now you can proceed with voting.</p> <p></p> <p>Any changes to the karma Tags of the DAO will be accepted through the vote.</p> <p>After the proposal is accepted, on the \"Members\" tab, you have the ability to assign Expert Tags to DAO members based on their experience.</p> <p>To assign Expert Tags to DAO members based on their experience, you'll need to navigate to the Members tab. </p> <p>Once there, you can select the appropriate Tag from the drop-down list and assign it to the respective member. This is a great way to highlight the skills and expertise of your DAO members and make it easier for others to identify who to turn to for specific tasks or advice.</p> <p>Please make sure to include a detailed description of the proposal regarding changes in allowances for members. It is important to provide all the necessary information for members of DAO to make informed decisions making the voting process.</p> <p>Then click on the Save changes and create proposal button:</p> <p></p> <p>You will redirected to the event page in the DAO tab. Now you can proceed with voting.</p> <p></p> <p>Expert Tags will be assigned to DAO members after the proposal is accepted and they will be able to use them for work.</p>"},{"location":"hacks-and-grants/user-guide/#grant-program","title":"Grant Program","text":"<p>coming soon</p>"},{"location":"integrations/contracts/","title":"Contracts","text":""},{"location":"integrations/contracts/#profile","title":"Profile","text":"<p>this contract is deployed for each user when registering with GOSH. It stores the user's name and its public keys.</p> <p>[source code]</p> <p>[ABI]</p> <p>getAccess() returns(mapping(uint256 =&gt; uint8))</p> <p>RETURNS:  </p> <p>the list of all the user's public keys with their numbers. It is necessary to take the zeroth pubkey from the list</p>"},{"location":"integrations/contracts/#versioncontroller","title":"VersionController","text":"<p>a contract version manager used when upgrading GOSH smart contracts</p> <p>[source code]</p> <p>[ABI]</p> <p>Info</p> <p>address (permanent): </p> <pre><code>0:5cbbbce41fc4290f3d4b085ab30912831b710fa2c681f6ea227d4a22f2b304f5\n</code></pre> <p>getProfileAddr(string name) returns(address)</p> <p>The function for getting the address of the user's *Profile***</p> <p>PARAMETERS:  </p> <ul> <li><code>name</code> (string) - user's name</li> </ul> <p>RETURNS:  </p> <p>the address of the user's Profile contract</p>"},{"location":"integrations/contracts/#elock","title":"ELOCK","text":"<p>is a GOSH L2 smart contract on Ethereum Blockchain. It receives deposits from users, manages withdrawals, and locks user funds. ELOCK also counts its total balance, and total transaction count and stores root Merkle proofs, withdrawal smart contract code hash, etc. for L2 synchronization.</p> <p>[ABI]</p> <p>Info</p> <p>address in Ethereum: </p> <pre><code>0x54a858bBD5968Eb755e54C45a3fe5B002bE3c254\n</code></pre> <p>deposit(uint256 pubkey)  </p> <p>Allows a user to deposit <code>Ether</code> (transfered as value) into the Elock-contract for locking in it. The corresponding amount of wrapped tokens (<code>WETH</code>) in GOSH will be minted for the amount of the blocked funds.</p> <p>PARAMETERS:  </p> <ul> <li><code>pubkey</code>  (uint256) - the recipient's public key in GOSH. Used to derive the address of the user's token wallet for minting wrapped tokens to it.</li> </ul> <p>example of calling the ELock contract in Ethereum</p> <pre><code>const elock = new data.web3.instance.eth.Contract(\n    ELockAbi.abi,\n    AppConfig.elockaddr,\n)\n\nconst edata = elock.methods.deposit(data.summary.to.user.value.pubkey).encodeABI()\n\nconst receipt = await data.web3.instance.eth.sendTransaction({\n    from: data.web3.address,\n    to: AppConfig.elockaddr,\n    value: data.web3.instance.utils.toWei(data.summary.from.amount, 'ether'),\n    data: edata,\n    gasLimit: 100000,\n    maxPriorityFeePerGas: 25000,\n})\n</code></pre> <p>depositERC20(address token, uint256 value, uint256 pubkey)  </p> <p>Allows a user to deposit ERC20 tokens into the Elock-contract for locking in it.  The corresponding amount of wrapped tokens in GOSH will be minted for the amount of the blocked funds. Before calling deposit, the specified number of tokens must be available for transfer for the Elock address.</p> <p>PARAMETERS:  </p> <ul> <li><code>token</code> (address) - address of the ERC20 token contract.  </li> <li><code>value</code> (uint256) - deposited number of tokens.  </li> <li><code>pubkey</code> (uint256) - the recipient's public key in GOSH. Used to derive the address of the user's token wallet for minting wrapped tokens to it.</li> </ul> <p>withdrawERC20(address token)  </p> <p>Requests the withdrawal of the specified tokens for the caller (<code>msg.sender</code>). Tokens must be approved for withdrawal. The commission must be attached to the function call.</p> <p>PARAMETERS:  </p> <ul> <li><code>token</code> (address) - address of the ERC20 token contract.</li> </ul> <p>getERC20Approvement(address token, address recipient) returns (uint value, uint commission)  </p> <p>For the specified token and recipient, it returns the number of tokens available for withdrawal (withdrawERC20) and the commission to be transferred for the withdrawal function.</p> <p>PARAMETERS:  </p> <ul> <li><code>token</code> (address) - address of the ERC20 token contract.  </li> <li><code>recipient</code> (address) - the address of the recipient of the withdrawn tokens </li> </ul> <p>RETURNS:  </p> <p>value (uint256) - the number of tokens approved for withdrawal. commission (uint256) - the amount of commission for withdrawal.</p> <p>getTokenRoots() returns (address[] memory roots)</p> <p>The function returns an array of addresses where each address represents a supported ERC20 token in GOSH Ethereum L2.</p> <p>RETURNS:  </p> <p>roots (address[]) - list of addresses of ERC20 tokens</p>"},{"location":"integrations/contracts/#glock","title":"GLOCK","text":"<p>is a set \u043ef special contracts on GOSH Blockchain. Aside from managing TIP-3 distributed tokens they also manage the deposits and withdrawals assets of users. Contract <code>Checker.sol</code> receives an external message from <code>Proposer</code> with Ethereum blockchain proofs signed by the Ethereum Committee, checks the hash of the blocks lined up in the chain, and deploys the contract <code>Proposal.sol</code> that validators check and vote for the Ethereum blocks in GOSH then receives a list of verified transactions and send a message to the root contract <code>RootTokenContract.cpp</code></p>"},{"location":"integrations/contracts/#checker","title":"Checker","text":"<p>[ABI]</p> <p>Info</p> <p>address in GOSH: </p> <pre><code>0:17eb654c5fca0027d47a4564139df71bec46b2277d71f6674ecd9dc55e52fb78\n</code></pre> <p>getRootAddr(RootData data) returns(address)</p> <p>The function returns TIP-3 root contract address</p> <p>PARAMETERS</p> <ul> <li><code>RootData.name</code>     (string) - ERC20 token name;  </li> <li><code>RootData.symbol</code>   (string) - ERC20 token symbol;  </li> <li><code>RootData.decimals</code> (uint8)  - ERC20 token decimals;  </li> <li><code>RootData.ethroot</code>  (uint256)- ERC20 token address;</li> </ul> <p>RETURNS</p> <p>address TIP-3 root for wrapped ERC20 token in GOSH </p>"},{"location":"integrations/contracts/#roottokencontract","title":"RootTokenContract","text":"<p>is a smart contract on GOSH that manages user withdrawals. It receives TIP-3 transactions, verifies them and adds transactions to the counter index. Also it deploys the TIP-3 wallet contract (<code>TONTokenWallet.cpp</code>) and sends wrapped tokens there.</p> <p>[ABI]</p> <p>Info</p> <p>address for TIP-3 token <code>ETH</code>:</p> <pre><code>0:d6182377a82e7f159f1b9995b2582ac933791599a4da9d72cc2c7812f056592d\n</code></pre> <p>getWalletAddress(uint256 pubkey, address_opt owner)  </p> <p>The function for getting the user's TIP-3 wallet address</p> <p>PARAMETERS:  </p> <ul> <li><code>pubkey</code> - user's public key</li> <li><code>owner</code> - optional parameter, not used</li> </ul> <p>RETURNS:  </p> <p>user's wallet address</p>"},{"location":"integrations/contracts/#tontokenwallet","title":"TONTokenWallet","text":"<p>is a custom TIP-3 contract that runs in GOSH Masterchain. Allows to manage TIP-3 tokens and transfers it to Ethereum for withdrawal</p> <p>[ABI]</p> <p>transferToRecipient(     address_opt answer_addr,     Tip3Creds   to,     uint128     tokens,     uint128     evers,     uint128     keep_evers,     bool        deploy,     uint128     return_ownership,     opt   notify_payload ) <p>The function for deploying empty TIP-3 wallet to another user</p> <p>PARAMETERS:  </p> <ul> <li><code>answer_addr</code> - Answer address, (should be <code>null</code>) </li> <li><code>to</code> - Recipient credentials (pubkey + owner (should be <code>null</code>))  </li> <li><code>tokens</code> - Amount of tokens to transfer, (should be <code>0</code>) </li> <li><code>evers</code> - Native funds to process. For internal requests, this value is ignored and processing costs will be taken from attached value  </li> <li><code>keep_evers</code> - Evers to keep in destination wallet  </li> <li><code>deploy</code> - (should be <code>true</code>) then the contract will send acceptTransfer message with StateInit to also deploy new TIP-3 wallet (if it doesn't already exist) with the provided recipient public key and recipient internal owner  </li> <li><code>return_ownership</code> - Return ownership - to decrease lend ownership for the caller contract (additionally), (should be <code>0</code>) </li> <li><code>notify_payload</code> - (optional) &lt; Payload (arbitrary cell) - if specified, will be transmitted into dest owner's notification, (should be <code>0</code>) </li> </ul> <p>transfer(     address_opt answer_addr,     address     to,     uint128     tokens,     uint128     evers,     uint128     return_ownership,     opt   notify_payload )   <p>The function transfers the TIP3-tokens between TIP-3 user wallets.</p> <p>PARAMETERS:  </p> <ul> <li><code>answer_addr</code>      - (optional) Answer address (should be <code>null</code>) </li> <li><code>to</code>               - Destination TIP-3 wallet address  </li> <li><code>tokens</code>           - Amount of tokens to transfer  </li> <li><code>evers</code>            - Native funds to process. For internal requests, this value is ignored and processing costs will be taken from attached value  </li> <li><code>return_ownership</code> - Return ownership - to decrease lend ownership provided for the caller contract (additionally) (should be <code>0</code>) </li> <li><code>notify_payload</code>   - Payload (arbitrary cell) - if specified, will be transmitted into dest owner's notification (should be <code>null</code>)</li> </ul> <p>burnTokens(uint128 tokens, uint256 to)</p> <p>The function burns tokens for transfer to Ethereum</p> <p>PARAMETERS:  </p> <ul> <li><code>tokens</code> - amount WETH, which will be transferred to Ethereum  </li> <li><code>to</code> - the address of the recipient's wallet in Ethereum</li> </ul> <p>getDetails()</p> <p>The function returns information about the TIP-3 wallet</p> <p>RETURNS:  </p> <p>the data structure:</p> <pre><code>struct details_info {\n  string            name;           // Token name.\n  string            symbol;         // Token short symbol.\n  uint8             decimals;       // Decimals for ui purposes. ex: balance 100 with decimals 2 will be printed as 1.00.\n  uint128           balance;        // Token balance of the wallet.\n  uint128           locked;         // Locked token balance of the wallet.\n  uint256           root_pubkey;    // Public key of the related RootTokenContract.\n  address           root_address;   // Address of the related RootTokenContract.\n  uint256           wallet_pubkey;  // Public key of wallet owner (User id for FlexWallet).\n  address_opt       owner_address;  // Owner contract address for internal ownership, will be 0:0..0 otherwise.\n  opt&lt;uint256&gt;      lend_pubkey;    // Lend ownership pubkey.\n  lend_owners_array lend_owners;    // All lend ownership records of the contract.\n  uint128           lend_balance;   // Summarized lend balance to all targets.\n                                    // Actual active balance will be `balance - lend_balance`.\n  opt&lt;bind_info&gt;    binding;        // Flex binding info.\n  uint256           code_hash;      // TIP-3 wallet code hash to verify other wallets.\n  uint16            code_depth;     // TIP-3 wallet code depth to verify other wallets.\n  int8              workchain_id;   // Workchain id.\n}\n</code></pre>"},{"location":"integrations/contracts/#giver-for-acki-nacki-test-network","title":"Giver for Acki Nacki test network","text":"<p>This is a giver for receiving test tokens on the https://ackinacki-testnet.tvmlabs.dev/</p> <p>[ABI]</p> <p>transferToRecipient(     address_opt answer_addr,     Tip3Creds   to,     uint128     tokens,     uint128     evers,     uint128     keep_evers,     bool        deploy,     uint128     return_ownership,     opt   notify_payload ) <p>The function for deploying empty TIP-3 wallet to another user</p> <p>PARAMETERS:  </p> <ul> <li><code>answer_addr</code> - Answer address, (should be <code>null</code>) </li> <li><code>to</code> - Recipient credentials (pubkey + owner (should be <code>null</code>))  </li> <li><code>tokens</code> - Amount of tokens to transfer, (should be <code>0</code>) </li> <li><code>evers</code> - Native funds to process. For internal requests, this value is ignored and processing costs will be taken from attached value  </li> <li><code>keep_evers</code> - Evers to keep in destination wallet  </li> <li><code>deploy</code> - (should be <code>true</code>) then the contract will send acceptTransfer message with StateInit to also deploy new TIP-3 wallet (if it doesn't already exist) with the provided recipient public key and recipient internal owner  </li> <li><code>return_ownership</code> - Return ownership - to decrease lend ownership for the caller contract (additionally), (should be <code>0</code>) </li> <li><code>notify_payload</code> - (optional) &lt; Payload (arbitrary cell) - if specified, will be transmitted into dest owner's notification, (should be <code>0</code>) sendTransaction</li> </ul>"},{"location":"integrations/l2/","title":"GOSH Ethereum L2","text":""},{"location":"integrations/l2/#introduction","title":"Introduction","text":"<p>Endpoint for use with Ever-SDK</p> <pre><code>network main: https://network.gosh.sh\n</code></pre> <p>To explore the GOSH blockchain, you can use the GOSH explorer</p> <p>First you need to get the address of user's profile. The contract Profile is deployed for each user when registering with GOSH.</p> <p>To get its address, you need to call the method <code>getProfileAddr</code> of the VersionController contract </p>"},{"location":"integrations/l2/#transfer-tokens","title":"Transfer tokens","text":""},{"location":"integrations/l2/#from-gosh-to-gosh","title":"from GOSH to GOSH","text":"<p>Before transferring to another TIP-3 wallet, you need to check whether the recipient's TIP-3 wallet is already deployed.</p> <p>To do this, you need to call the method <code>getWalletAddress</code> in the RootTokenContract, the recipient's public key is specified.</p> <p>If the recipient's TIP-3 wallet is not deployed, you need to call the method <code>transferToRecipient</code> in the TIP-3 wallet contract \"TONTokenWallet\" (from which the transfer will be made).</p> <p>Example</p> <pre><code>await this.run('transferToRecipient', {\n    _answer_id: 0,\n    answer_addr: null,\n    to: { pubkey, owner: null },\n    tokens: 0,\n    evers: BigInt(4.5 * 10 ** 9).toString(),\n    keep_evers: BigInt(4 * 10 ** 9).toString(),\n    deploy: true,\n    return_ownership: 0,\n    notify_payload: null,\n})\n</code></pre> <p>As a result, an empty TIP-3 wallet will be deployed to the recipient.</p> <p>Warning</p> <p>It is important to wait until the contract status changes to \"Active\".</p> <p>Then, for transfer the TIP-3 tokens to the user, you need to call the method <code>transfer</code> in the TONTokenWallet contract.</p> <p>Example</p> <pre><code>await this.run('transfer', {\n    _answer_id: 0,\n    answer_addr: null,\n    to: address,\n    tokens: amount.toString(),\n    evers: BigInt(4 * 10 ** 9).toString(),\n    return_ownership: 0,\n    notify_payload: null,\n})\n</code></pre>"},{"location":"integrations/l2/#from-ethereum-to-gosh","title":"from Ethereum to GOSH","text":"<p>For transfer tokens to GOSH, you need to call the method:</p> <ul> <li>for <code>ETH</code>: <code>deposit</code></li> <li>for <code>ERC20</code> tokens: <code>depositERC20</code></li> </ul> <p>in the ELOCK contract.</p> <p>Then it is necessary to calculate the address of the user's TIP-3 wallet in GOSH and wait the transfer of tokens to the received TIP3 user wallet in GOSH.</p>"},{"location":"integrations/l2/#from-gosh-to-ethereum","title":"from GOSH to Ethereum","text":"<p>To transfer tokens to Ethereum, you will need to call method:</p> <ul> <li>for <code>ETH</code>: <code>burnTokens</code></li> <li> <p>for <code>ERC20</code> tokens: <code>withdrawERC20</code></p> <p>(then to call <code>getERC20Approvement</code> to determine the commission that needs to be attached to the withdrawal function call)</p> </li> </ul> <p>in the user contract TONTokenWallet</p> <p>Then wait for the receipt of tokens to the recipient's Ethereum wallet.</p>"},{"location":"integrations/l2/#getting-the-users-tip-3-wallet-address","title":"Getting the user's TIP-3 wallet address:","text":""},{"location":"integrations/l2/#using-by-user-name","title":"using by user name","text":"<p>Knowing the address of the user's contract Profile you call the method <code>getAccess</code> in it.</p> <p>As a result, you get a list of all the user's public keys with their numbers.</p> <p>Important</p> <p>It is necessary to take the zeroth pubkey from the list</p> <p>Then, using the received user's public key, it will be possible to determine the address of the user's TIP-3 wallet</p>"},{"location":"integrations/l2/#using-the-users-public-key","title":"using the user's public key","text":"<p>To do this, in the RootTokenContract calling method <code>getWalletAddress</code> </p>"},{"location":"integrations/l2/#getting-a-list-of-incoming-messages-of-the-contract","title":"Getting a list of incoming messages of the contract","text":"<p>Example</p> <p>of how to receive account messages</p> <p>Info</p> <p>Using pagination in the SDK</p>"},{"location":"integrations/l2/#get-info-about-tip-3-wallet-details","title":"Get info about TIP-3 wallet details","text":"<p>To get information about the TIP-3 wallet you will need to call the <code>getDetails</code> method in the contract TONTokenWallet</p>"},{"location":"integrations/l2/#get-tip-3-root-list","title":"Get TIP-3 root list","text":"<p>To get a list of ERC20 token addresses that are supported in GOSH Ethereum L2, you need to call the <code>getTokenRoots</code> method in the ELOCK contract.</p> <p>For every ERC20 token in the given list, execute the following get-methods: <code>name</code> <code>symbol</code> <code>decimals</code></p> <p>After that, you need to call the method <code>getRootAddr</code> in the Checker contract with the received data</p>"},{"location":"on-chain-architecture/gosh-smart-contracts/","title":"GOSH smart contracts","text":"<p>GOSH is open-source and freely available on GitHub </p> <p>GOSH is the most secure Git Implementation in existence. It stores, manages and processes all the editable GIT objects entirely on-chain. It verifies the correctness of all object mutations by invoking automatic checks and verifications by smart contracts.  </p> <p>GOSH provides developers with a secure and transparent platform to collaborate on open-source projects and ensure the security of their software development and delivery as part of the software supply chain.</p> <p>This is the general scheme of interaction between GOSH smart contracts:</p> <p> </p> <p>GOSH consists of the following contracts (latest version):</p> <ul> <li>VersionController - a contract version manager used when upgrading GOSH smart contracts</li> <li>SystemContract - main contract for hosting any specific version of GOSH smart contracts</li> <li>Profile  - a contract for a user's profile on GOSH</li> <li>ProfileIndex - a contract for each user's public key</li> <li>ProfileDao  - a contract of a DAO's profile on GOSH</li> <li>GOSHWallet  - user wallet for all user interactions with GOSH</li> <li>GoshDao  - a contract storing organizations' objects</li> <li>Repository  - a contract storing repositorys' objects</li> <li>Commit  - a contract storing commits' objects</li> <li>Tree  - a contract storing trees' objects</li> <li>Diff  - a contract storing diffs' objects</li> <li>Snapshot  - a contract storing snapshots' objects</li> <li>Tag - a contract storing gits' tag object</li> <li>DaoTag - a contract responsible for tags in a DAO</li> <li>RepoTagGosh - a contract responsible for tags in a repository</li> <li>Task - a contract storing a task object</li> <li>Topic - a contract storing the description of an object</li> </ul>"},{"location":"on-chain-architecture/gosh-wallet/","title":"GOSH Wallet","text":"<p>The GOSH blockchain is a system of interconnected smart contracts. Every repository, every file and commit are smart contracts, where data is written to the blockchain.</p> <p>Writing data to the blockchain requires cryptographic signatures and fees.</p> <p>For this reason every GOSH user needs to have a wallet and a pair of cryptographic keys. </p> <p>Every operation on GOSH is carried out by user wallets.</p> <p>Info</p> <p>GOSH wallets are written with the express purpose of facilitating open-source development.</p> <p>Fees on GOSH are not paid to Validators but are instead transferred to the Free Software Giver \u2014 Which funds the GOSH Free Service Area  \u2014 these fees are used to replenish the Special User Wallet contracts to automatically pay for gas fees of other contracts in the Free Service Area.</p> <p>These contracts can only transfer tokens between other contracts within the Area and are not transferable outside, meaning they are pure Utility Tokens. These tokens are SHELL coins, here used as a Unit of Account for Payment Gateways.</p> <p>So in effect this means any developer can use the GOSH blockchain for free, without paying any gas, and sell their services using Fiat Payment Gateways without a need to KYC/AML. This payment Gateway is built into GOSH.</p> <p>There are two types of wallets GOSH users can deploy:</p> <ul> <li> <p>A DAO Member Wallet, which is deployed to a GOSH user after they become a member of a DAO. This wallet stores both voting and non-voting tokens</p> </li> <li> <p>A Limited Wallet (for non-DAO members), which is deployed to a GOSH user when they view any DAO or if non-voting tokens of any DAO were transferred to them.</p> <p>A user with a Limited Wallet in the DAO can:</p> <ul> <li> <p>create a proposal to add yourself to the DAO (if it is allowed in the dao);</p> </li> <li> <p>can be assigned as a reviewer to the Task;</p> </li> <li> <p>can create a proposal on PR (coming soon).</p> </li> </ul> </li> </ul> <p>Info</p> <p>For a DAO member, not one wallet is deployed, but a whole system of 64 wallet contracts. This allows for parallelization when sending external messages.</p> <p>Refer to GOSH Web or Docker Extension sections to find out how to create your account and get started with GOSH.</p>"},{"location":"on-chain-architecture/organizations-gosh-dao-and-smv/","title":"Organizations: GOSH DAO and SMV","text":""},{"location":"on-chain-architecture/organizations-gosh-dao-and-smv/#dao","title":"DAO","text":"<p>Every repository on GOSH is managed as a Decentralized Autonomous Organization - DAO \u2013 a tool that allows every developer to build on GOSH in a way that is decentralized, secure, and scalable.</p> <p>Every organization has, as a minimum, one member who creates and manages repositories. However, once more than one user is added to a DAO, it is then governed through decentralized management mechanisms.</p> <p>Your can configure your DAO easily. The main of these mechanisms is voting. Any action in a DAO requires a vote and is created through proposals. For example, a user may propose to commit of file into a repository, and a soft-majority vote (SMV) of all other DAO members may be required to approve it. Branches could be locked to require any changes to them to be voted on by DAO SMV.</p>"},{"location":"on-chain-architecture/organizations-gosh-dao-and-smv/#soft-majority-voting","title":"Soft Majority Voting","text":"<p>Soft Majority Voting, or SMV for short, is a voting mechanism designed for transparency and optional participation.</p> <p>The outcome of a Soft Majority Vote is decided by the difference between the number of votes for, and the number of votes against a proposal. If nobody objects, a minimum threshold of approving votes is required for the proposal to pass.</p> <p>If everyone votes either for or against a proposal, 50% + 1 vote is required for the proposal to pass.</p> <p>If the only votes given are for the proposal, and no one votes against, 10% approving votes are enough for the proposal to pass immediately.</p> <p>Everything in between these two extremes is a linear dependency between the percentage of votes against and the percentage of votes for, that is required for the proposal to pass.</p> <p>For important decisions a more strict super majority approval criteria may be set up.</p> <p></p> <p>All SMV proposals have a set deadline. When it is reached, accumulated votes are counted, the decision is made, and the proposal pass.</p> <p>If, however, a majority of 50% + 1 vote is reached early, the proposal passes immediately.</p>"},{"location":"on-chain-architecture/organizations-gosh-dao-and-smv/#smv-in-gosh","title":"SMV in GOSH","text":"<p>In GOSH one vote is one token.</p>"},{"location":"on-chain-architecture/organizations-gosh-dao-and-smv/#tokens-and-karma","title":"Tokens and Karma","text":"<p>The total supply of tokens is set when a DAO is created.</p> <p>A DAO's first user automatically gets 20 DAO tokens and 20 Karma.</p> <p>Karma is the amount of tokens (upper limit) within which a DAO member can vote.</p> <p>Karma is either granted by a DAO decision upon member acceptance or earned through repository contribution. This determines the reputation of a DAO member. The Karma can be changed only by voting.</p> <p>See here for more information.</p>"},{"location":"on-chain-architecture/organizations-gosh-dao-and-smv/#voting","title":"Voting","text":"<p>If several members jointly vote for a proposal with 50% + 1 token of the Global Karma Count of a DAO then the proposal passes early.</p> <p>Global Karma Count is the total amount of Karma calculated by summing up the Karma of all DAO members at the time of the proposal creation.</p> <p>If no one objects to a proposal for the duration of its voting period, 10% of the Global Karma Count is enough, but the proposal will only pass at the end of the voting period.</p> <p>If votes are split, and neither side achieves 50% + 1 token early, the proposal completes at the end of the voting period and the result is calculated according to the SMV diagram above.</p>"},{"location":"user-guide/architecture/","title":"Architecture","text":"<ol> <li>Build a scalable multithreaded, multisharded content addressable blockchain</li> <li>Implement Git using smart contracts</li> <li>Implement DAO on top of that Git to allow building consensus around the code</li> <li>Formally verify the smart contracts</li> <li>Represent all entities by hashes (container images, git commits, bl\u043ebs, pull requests etc.);</li> <li>Allow anyone to add some metadata with signature to any entity;</li> <li>Allow anyone to decide whose metadata to trust;</li> <li>Build chain/tree of trust: dependencies can be organized using the same architecture, and containers built</li> </ol>"},{"location":"user-guide/git-open-source-hodler/","title":"Git open source hodler","text":"<p>(Yes, it's Hodler).</p> <p>GOSH is a blockchain built around securing the software supply chain and capturing the immense value in open source projects. This is achieved through record-setting blockchain tech, distributed programming, and a decentralized architecture - integrated into the same familiar git, meaning there is no change to the workflow.</p>"},{"location":"user-guide/instruments-and-utilities/","title":"Instruments and utilities","text":"<p>A variety of utility tools to assist with all the aspects of the solution are under active development. Explore the tools available now to get started with GOSH:</p> <ul> <li>create and manage your on-chain repositories through GOSH Web or directly in the Docker Extension</li> <li>work with on-chain repository as if you use a regular git repository with Git Remote Helper</li> </ul>"},{"location":"user-guide/motivation/","title":"Motivation","text":"<p>The Software Supply Chain is a high-impact area. Yet there exists a distinctive lack of secure, trustless, verifiable, and transparent delivery of source code/binaries to developers and users in all software fields. Storing your code on a git means it has an owner, a single point of control, which leads to security vulnerabilities. Currently there is no industrial solution available that is not centralized and thus not dependent on the decisions of a few actors. The main way in which GOSH solves this issue is through allowing developers to build consensus around their code, so the more code is written, the more secure it becomes.</p>"},{"location":"user-guide/objective/","title":"Objective","text":"<p>To create a truly decentralized development environment so that open source repositories can be run, governed, and monetized collectively. All the while, mitigating security and transparency issues arising from a conventional software supply chain.</p>"},{"location":"working-with-gosh/anytree-firewall-for-telepresence/","title":"AnyTree Firewall for Telepresence","text":""},{"location":"working-with-gosh/anytree-firewall-for-telepresence/#overview","title":"Overview","text":"<p>The GOSH AnyTree Firewall integration with Telepresence is designed to make sure everything developed with Telepresence for Docker will be identically reproduced with every build, regardless of other changes made in the development process. The integration tool provides an additional security measure, so  developers can build software faster and with confidence.</p> <p>Part of the GOSH AnyTree Firewall is the \u2018Deep SBOM\u2019 -  a tool describing not only what, but also how something was built, and uses GOSH Anytree Builder to safely build reproducible containers in an isolated environment.</p> <p>GOSH AnyTree Firewall is currently in Beta testing stages on Linux only, but will be available on other platforms and Docker Desktop in the near future.</p>"},{"location":"working-with-gosh/anytree-firewall-for-telepresence/#quick-start","title":"Quick start","text":""},{"location":"working-with-gosh/anytree-firewall-for-telepresence/#for-linux","title":"for Linux","text":"<ol> <li> <p>Install Git Remote Helper using the installation script</p> <pre><code>wget -O - \\\n  https://raw.githubusercontent.com/gosh-sh/gosh/dev/install.sh \\\n  | bash -s\n</code></pre> <p>Checking the installation results.</p> </li> <li> <p>Install GOSH AnyTree using the installation script</p> <pre><code>wget -O - \\\n  https://raw.githubusercontent.com/gosh-sh/gosh-build-tools/dev/install.sh \\\n  | bash -s\n</code></pre> <p>You can check installation by running:</p> <pre><code>gosh anytree --help\n</code></pre> </li> <li> <p>Install Kubernetes with Telepresence the Traffic Manager</p> <p>Warning</p> <p>We need to return docker's context to default.</p> <pre><code>docker context use default\n</code></pre> <p>To see all available docker's contexts type:</p> <pre><code>docker context list\n</code></pre> </li> <li> <p>Start Telepresence with AnyTree Firewall</p> <pre><code>telepresence intercept [OPTIONS] --docker-build \\\n  gosh://0:0d5...e92c/&lt;your_dao&gt;/&lt;your_repo&gt;#&lt;commit_or_branch_or_tag&gt; \\\n  &lt;k8s_pod_name&gt;\n</code></pre> </li> </ol>"},{"location":"working-with-gosh/anytree/","title":"AnyTree","text":""},{"location":"working-with-gosh/anytree/#overview","title":"Overview","text":"<p>GOSH introduces AnyTree \u2014 a software deployment system built to guarantee the security of your software supply chain</p> <p>With AnyTree, any mutations of your code, down to every dependency, as well as operations, including builds and every artifact, are logged, timestamped, signed, and verified when used on GOSH</p> <p>Deep SBOM extends the SBOM surface to include all build environments. It is impossible to inject malicious commits backwards on GOSH and miss dependency tampering during the CI/CD process when using Deep SBOM. Integrating GOSH Builder with AnyTree proves builds on a developer machine and a server (or a cloud) are identical</p> <p>AnyTree utilizes standard Docker Containers secured by GOSH AnyTree Builder and is currently available as Beta on Linux and is coming soon to Windows and macOS.</p> <p>As the result of his work will be the creation of a binary file of project. It is describing not only what, but also how something was built.</p> <p>Info</p> <p>The current version of AnyTree only supports Linux.</p>"},{"location":"working-with-gosh/anytree/#quick-start","title":"Quick start","text":"<ol> <li> <p>Install Git Remote Helper using the installation script</p> <pre><code>wget -O - \\\n  https://raw.githubusercontent.com/gosh-sh/gosh/dev/install.sh \\\n  | bash -s\n</code></pre> <p>Checking the installation results.</p> </li> <li> <p>Install AnyTree using the installation script</p> <pre><code>wget -O - \\\n  https://raw.githubusercontent.com/gosh-sh/anytree/dev/install.sh \n  | bash -s\n</code></pre> <pre><code>export PATH=$PATH:$HOME/.gosh\n</code></pre> <p>By default, script installs latest release to the default path <code>$HOME/.gosh/</code>, but you can customize it with env variables:</p> <pre><code>TAG=0.3.0 BINARY_PATH=/usr/local/bin ./install.sh\n</code></pre> <p>You can check installation by running:</p> <pre><code>anytree --help\n</code></pre> </li> <li> <p>Setup a GOSH project</p> <p>You need a GOSH repository. If you haven't used a GOSH-repository you can upload your github-repository to GOSH through onboarding or create a GOSH-account and create a new one.</p> <p>Go to your GOSH-repository</p> <p>and run:</p> <pre><code>gosh init\n</code></pre> </li> <li> <p>Generation <code>SBOM file</code></p> <p>Prerequisites:</p> <ul> <li>Docker</li> <li>Python3 with pip (required to generate a <code>SBOM-file</code>)</li> </ul> <p>To create artifacts, you will need an <code>SBOM file</code> created  according to the Cyclone DX specification</p> <p>Info</p> <p>The example file can be viewed here</p> <p>If you have a Rust project, you can generate an <code>SBOM file</code> using the script generate-sbom.py (scripts for other programming languages will coming soon)</p> <p>Note</p> <p>either copy script to your cargo project and run <code>python3 generate-sbom.py</code> or check and configure variables in script</p> <p></p> <p>Info</p> <p>If necessary, install the dependencies for the script to work. Run in the folder where the script is located:</p> <pre><code>pip3 install -r requirements.txt\n</code></pre> <p>Possible options are described in the help:</p> <pre><code>python3 generate-sbom.py --help\n</code></pre> <p>After running the script you should get the following output at the end:</p> <pre><code>Updated SBOM written to /home/user/gosh/v5_x/v5.1.0/git-remote-gosh/sbom.json\n</code></pre> </li> <li> <p>Now you are ready to build artifact</p> <p>run:</p> <pre><code>anytree build sbom.json\n</code></pre> <p>As a result, a binary file of project will be created and you should get similar output at the end:</p> <p><pre><code>Successfully copied 15.8MB to /home/user/.cache/anytree/builder/anytree-builder-5aba4439-2642-4b7f-bc3c-affd8c9839fd/target\n</code></pre> And your artifacts will be accessible in this folder</p> <p>Warning</p> <p>If the hash that was calculated when creating the SBOM file differs from the hash that AnyTree checks, an error like this will be output:</p> <p></p> <p>Tip</p> <p>Place the SBOM-file in the same folder where <code>GOSH.yaml</code> is located.</p> </li> </ol>"},{"location":"working-with-gosh/anytree/#installation-anytree","title":"Installation AnyTree","text":"<p>Before installing AnyTree, you must already have the Git Remote Helper installed.</p> <p>If you have Linux you can use these installation methods:</p>"},{"location":"working-with-gosh/anytree/#install-anytree-using-the-installation-script","title":"Install AnyTree using the installation script","text":"<pre><code>wget -O - https://raw.githubusercontent.com/gosh-sh/anytree/dev/install.sh | bash -s\n</code></pre>"},{"location":"working-with-gosh/anytree/#install-anytree-from-source","title":"Install AnyTree from source","text":"<ol> <li> <p>Prerequisites:</p> <ul> <li>Rust v1.66+</li> <li>Protobuf Compiler</li> <li><code>git</code></li> <li><code>make</code></li> </ul> </li> <li> <p>Clone AnyTree repository</p> </li> <li> <p>Run make install to build GOSH <code>anytree tool</code></p> </li> </ol>"},{"location":"working-with-gosh/anytree/#setup-a-gosh-project","title":"Setup a GOSH project","text":"<p>You need a GOSH repository. If you haven't used a GOSH-repository you can upload your github-repository to GOSH through onboarding or create a GOSH-account and create a new one.</p> <p>Go to your GOSH-repository you project</p> <p>and run:</p> <pre><code>gosh init\n</code></pre>"},{"location":"working-with-gosh/anytree/#generation-sbom-file","title":"Generation <code>SBOM file</code>","text":"<p>AnyTree builds the artifacts uses <code>SBOM file</code> that allows developers to see what they built and why and reproduce the same result.</p> <p>To create artifacts, you will need an <code>SBOM file</code> created  according to the Cyclone DX specification</p> <p>Info</p> <p>The example file can be viewed here: https://github.com/gosh-sh/anytree/blob/dev/tools/python/sbom.json</p> <p>If you have a Rust project, you can generate an <code>SBOM file</code> using the script generate-sbom.py (scripts for other programming languages will coming soon)</p> <p>Note</p> <p>either copy script to your cargo project and run <code>python3 generate-sbom.py</code> or check and configure variables in script</p> <p></p> <p>Prerequisites:</p> <ul> <li>Docker</li> <li>Python3 with pip (required to generate a <code>SBOM-file</code>)</li> </ul> <p>To generate a <code>SBOM file</code> for a Rust project, you can use the script generate-sbom.py</p> <p>Info</p> <p>If necessary, install the dependencies for the script to work. Run in the folder where the script is located:</p> <pre><code>pip3 install -r requirements.txt\n</code></pre> <p>Possible options are described in the help:</p> <pre><code>python3 generate-sbom.py --help\n</code></pre> <pre><code>usage: generate-sbom.py [-h] [--cargo-lock CARGO_LOCK_PATH] [--cargo-toml CARGO_TOML_PATH] [--initial-sbom INITIAL_SBOM_PATH]\n                        [--sbom-output SBOM_OUTPUT_PATH] [--project-src PROJECT_SRC_PATH] [--project-commit PROJECT_COMMIT]\n                        [--project-url PROJECT_URL]\n\nGenerate software bill of materials (SBOM) for Rust project\n\noptions:\n-h, --help            show this help message and exit\n--cargo-lock CARGO_LOCK_PATH\n                        Path to Cargo.lock file. Default - ./Cargo.lock\n--cargo-toml CARGO_TOML_PATH\n                        Path to Cargo.toml file. Default - ./Cargo.toml\n--initial-sbom INITIAL_SBOM_PATH\n                        Optional. Path to initial SBOM JSON file if need to append existing SBOM. Default - initial-sbom.json. Will ignore\n                        if file doesn't exist.\n--sbom-output SBOM_OUTPUT_PATH\n                        Path to output SBOM JSON file. Default - sbom.json\n--project-src PROJECT_SRC_PATH\n                        Path to the Rust project source if not in root git directory. Not relates to local file system path. Relates to\n                        path inside repo structure. For example we can use v5_x/v5.1.0/git-remote-gosh which means https://github.com/gosh-\n                        sh/gosh/v5_x/v5.1.0/git-remote-gosh\n--project-commit PROJECT_COMMIT\n                        Commit of the project. Default - commit parsed with 'git rev-parse HEAD' command in dir where Cargo.lock is\n                        located.\n--project-url PROJECT_URL\n                        URL of the project's repository. Default - project URL parsed with 'git config --get remote.origin.url' command in\n                        dir where Cargo.lock is located.\n</code></pre> <p>For_example</p> <p>Run the generation of the <code>SBOM-file</code> for the rust project <code>Git Remote Helper</code> latest version:</p> <pre><code>python3 ~/gs/generate-sbom.py --cargo-lock ~/gosh/v5_x/v5.1.0/git-remote-gosh/Cargo.lock --cargo-toml ~/gosh/v5_x/v5.1.0/git-remote-gosh/Cargo.toml --sbom-output ~/gosh/v5_x/v5.1.0/git-remote-gosh/sbom.json --project-src v5_x/v5.1.0/git-remote-gosh\n</code></pre> <p>The script downloads all dependencies specified in <code>cargo.lock</code>, counts all hashes and the generated sbom.json will be placed in the root folder of the project.</p> <p>After running the script you should get the following output at the end:</p> <pre><code>Updated SBOM written to /home/user/gosh/v5_x/v5.1.0/git-remote-gosh/sbom.json\n</code></pre> <p>And generated <code>sbom.json</code> file in the following format </p>"},{"location":"working-with-gosh/anytree/#working-with-anytree","title":"Working with AnyTree","text":"<p>run:</p> <pre><code>anytree build sbom.json\n</code></pre> <p>As a result, a binary file of project will be created and you should get similar output at the end:</p> <pre><code>Successfully copied 15.8MB to /home/user/.cache/anytree/builder/anytree-builder-5aba4439-2642-4b7f-bc3c-affd8c9839fd/target\n</code></pre> <p>And your artifacts will be accessible in this folder</p> <p>If the hash that was calculated when creating the SBOM file differs from the hash that AnyTree checks, an error like this will be output:</p> <p></p> <p>Info</p> <p>For more information about the options, see the Help section:</p> <pre><code>anytree --help\n</code></pre> <p>Info</p> <p>The developer can put the generated specification in his repository for further verification.</p>"},{"location":"working-with-gosh/anytree/#options","title":"Options","text":""},{"location":"working-with-gosh/anytree/#build","title":"build","text":"<p>Print help</p> <pre><code>-h, --help\n</code></pre> <p>Print version</p> <pre><code>-V, --version\n</code></pre>"},{"location":"working-with-gosh/anytree/#working-with-anytree-without-gosh","title":"Working with AnyTree without GOSH","text":"<p>Prerequisites:</p> <pre><code>* Docker\n* Python3 with pip (required to generate a `SBOM-file`)\n</code></pre> <ol> <li> <p>Install AnyTree</p> <pre><code>wget -O - https://raw.githubusercontent.com/gosh-sh/anytree/dev/install.sh | bash -s\n</code></pre> <pre><code>export PATH=$PATH:$HOME/.gosh\n</code></pre> <p>By default, script installs latest release to the default path <code>$HOME/.gosh/</code>, but you can customize it with env variables:</p> <pre><code>TAG=0.3.0 BINARY_PATH=/usr/local/bin ./install.sh\n</code></pre> </li> <li> <p>Now you need the <code>SBOM file</code>.</p> <p>Prerequisites:</p> <ul> <li>Docker</li> <li>Python3 with pip (required to generate a <code>SBOM-file</code>)</li> </ul> <p>To create artifacts, you will need an <code>SBOM file</code> created  according to the Cyclone DX specification</p> <p>Info</p> <p>The example file can be viewed here{:target=\"_blank\"}  </p> <p>If you have a Rust project, you can generate an <code>SBOM file</code> using the script generate-sbom.py (scripts for other programming languages will coming soon)</p> <p>Note</p> <p>either copy script to your cargo project and run <code>python3 generate-sbom.py</code> or check and configure variables in script</p> <p></p> <p>Info</p> <p>If necessary, install the dependencies for the script to work. Run in the folder where the script is located:</p> <pre><code>pip3 install -r requirements.txt\n</code></pre> <p>Possible options are described in the help:</p> <pre><code>python3 generate-sbom.py --help\n</code></pre> <pre><code>usage: generate-sbom.py [-h] [--cargo-lock CARGO_LOCK_PATH] [--cargo-toml CARGO_TOML_PATH] [--initial-sbom INITIAL_SBOM_PATH]\n                        [--sbom-output SBOM_OUTPUT_PATH] [--project-src PROJECT_SRC_PATH] [--project-commit PROJECT_COMMIT]\n                        [--project-url PROJECT_URL]\n\nGenerate software bill of materials (SBOM) for Rust project\n\noptions:\n-h, --help            show this help message and exit\n--cargo-lock CARGO_LOCK_PATH\n                        Path to Cargo.lock file. Default - ./Cargo.lock\n--cargo-toml CARGO_TOML_PATH\n                        Path to Cargo.toml file. Default - ./Cargo.toml\n--initial-sbom INITIAL_SBOM_PATH\n                        Optional. Path to initial SBOM JSON file if need to append existing SBOM. Default - initial-sbom.json. Will ignore\n                        if file doesn't exist.\n--sbom-output SBOM_OUTPUT_PATH\n                        Path to output SBOM JSON file. Default - sbom.json\n--project-src PROJECT_SRC_PATH\n                        Path to the Rust project source if not in root git directory. Not relates to local file system path. Relates to\n                        path inside repo structure. For example we can use v5_x/v5.1.0/git-remote-gosh which means s://github.com/gosh-\n                        sh/gosh/v5_x/v5.1.0/git-remote-gosh\n--project-commit PROJECT_COMMIT\n                        Commit of the project. Default - commit parsed with 'git rev-parse HEAD' command in dir where Cargo.lock is\n                        located.\n--project-url PROJECT_URL\n                        URL of the project's repository. Default - project URL parsed with 'git config --get remote.origin.url' command in\n                        dir where Cargo.lock is located.\n</code></pre> <p>For_example</p> <p>Run the generation of the <code>SBOM-file</code> for the rust project <code>Git Remote Helper</code> latest version:</p> <pre><code>python3 ~/gs/generate-sbom.py --cargo-lock ~/gosh/v5_x/v5.1.0/git-remote-gosh/Cargo.lock --cargo-toml ~/gosh/v5_x/v5.1.0/git-remote-gosh/Cargo.toml --sbom-output ~/gosh/v5_x/v5.1.0/git-remote-gosh/sbom.json --project-src v5_x/v5.1.0/git-remote-gosh\n</code></pre> <p>The script downloads all dependencies specified in <code>cargo.lock</code>, counts all hashes and the generated sbom.json will be placed in the root folder of the project.</p> <p>After running the script you should get the following output at the end:</p> <pre><code>Updated SBOM written to /home/user/gosh/v5_x/v5.1.0/git-remote-gosh/sbom.json\n</code></pre> <p>And generated <code>sbom.json</code> file in the following format </p> </li> <li> <p>Now you can use sbom.json to build your project.     run:</p> </li> </ol> <pre><code>    ```\n    anytree build sbom.json\n    ```\n</code></pre> <p>As a result, a binary file of project will be created and you should get similar output at the end:</p> <p><pre><code>Successfully copied 15.8MB to /home/user/.cache/anytree/builder/anytree-builder-5aba4439-2642-4b7f-bc3c-affd8c9839fd/target\n</code></pre> And your artifacts will be accessible in this folder</p> <p>Warning</p> <p>If the hash that was calculated when creating the SBOM file differs from the hash that AnyTree checks, an error like this will be output:</p> <p></p>"},{"location":"working-with-gosh/anytree/#known-issues","title":"Known issues","text":"<p>We would like to bring to your attention a memory limitation concern that has been identified when working with large repositories. Under certain circumstances, you might encounter memory depletion issues which could potentially affect your work efficiency and system performance. We deeply apologize for any inconvenience this may cause.</p> <p>Rest assured, we are committed to promptly resolving this issue. Our dedicated team of developers has already initiated efforts to address this, with an anticipated resolution targeted within the next two weeks. We appreciate your patience and understanding as we continue to enhance and streamline our services.</p>"},{"location":"working-with-gosh/anytree/#contact-us","title":"Contact us","text":"<p>If you have any questions or issues using GOSH AnyTree, please email us at help@gosh.sh</p>"},{"location":"working-with-gosh/build-and-sign-images/","title":"Build and Sign Images","text":"<p>With the Help of a custom Buildkit, you can build your Docker images directly from GOSH, and sign them so they can be verified by the GOSH docker extension.</p> <p>Instead of a dockerfile, this Buildkit uses a special goshfile to ensure code is taken from GOSH.</p>"},{"location":"working-with-gosh/build-and-sign-images/#how-to-build-from-gosh","title":"How to build from GOSH","text":""},{"location":"working-with-gosh/build-and-sign-images/#1-setup-environment-variables-with-your-wallet","title":"1. Setup environment variables with your wallet","text":"<pre><code>export WALLET=...\nexport WALLET_PUBLIC=...\nexport WALLET_SECRET=...\n</code></pre> <p>You received these when creating your account in GOSH Web or Docker Extension.</p>"},{"location":"working-with-gosh/build-and-sign-images/#2-create-goshfileyaml-this-specification-is-a-work-in-progress-and-subject-to-change","title":"2. Create <code>goshfile.yaml</code> (this specification is a work in progress and subject to change)","text":"<pre><code># syntax=teamgosh/goshfile\n\napiVersion: 1\nimage: bash:latest\nsteps:\n  - name: print date\n    run:\n      command: [\"/usr/local/bin/bash\"]\n      args:\n        - -c\n        - &gt;-\n          (date +'%s %H:%M:%S %Z'; echo \"Hi there\") | tee /message.txt\n</code></pre>"},{"location":"working-with-gosh/build-and-sign-images/#3-now-to-build-an-image","title":"3. Now to build an image","text":"<pre><code>TARGET_IMAGE=\"my-target-super-image\"\n\ndocker buildx build \\\n    --push \\\n    --label WALLET_PUBLIC=\"$WALLET_PUBLIC\" \\\n    -f goshfile.yaml \\\n    -t \"$TARGET_IMAGE\" \\\n    .\n\n## OR more complicated way via buildctl directly\n# # run buildkitd containered\n# docker run -d --name buildkitd --privileged moby/buildkit:latest\n# # build image\n# buildctl --addr=docker-container://buildkitd build \\\n#         --frontend gateway.v0 \\\n#         --local dockerfile=. \\\n#         --local context=. \\\n#         --opt source=teamgosh/goshfile \\\n#         --opt filename=goshfile.yaml \\\n#         --opt wallet_public=\"$WALLET_PUBLIC\" \\\n#         --output type=image,name=\"$TARGET_IMAGE\",push=true\n</code></pre> <p>Here we parameterize the image build process with our wallet credentials.</p>"},{"location":"working-with-gosh/build-and-sign-images/#4-sign-the-image-wip-will-be-part-of-build-image-process","title":"4. Sign the image (WIP: will be part of build image process)","text":"<pre><code>docker pull $TARGET_IMAGE # buildkit push image directly to the registry and it doesn't persist locally\n\n# my-target-super-image's sha256\nTARGET_IMAGE_SHA=`docker inspect --format='{{index (split (index .RepoDigests 0) \"@\") 1}}' $TARGET_IMAGE`\n\ndocker run --rm teamgosh/sign-cli sign \\\n    -n &lt;blockchain_network e.g. https://gra01.net.everos.dev&gt; \\\n    -g $WALLET \\\n    -s $WALLET_SECRET \\\n    $WALLET_SECRET \\  # signer secret can be different\n    $TARGET_IMAGE_SHA\n</code></pre> <p>Now you have signed the image.</p>"},{"location":"working-with-gosh/build-and-sign-images/#you-can-check-the-image-signature-with-your-public-key","title":"You can check the image signature with your public key","text":"<pre><code>TARGET_IMAGE=\"my-target-super-image\"\n# or IMAGE_NAME=\"my_repo:5000/library/my-target-super-image:latest@sha256:...\"\n\nWALLET_PUBLIC=$(docker inspect --format='{{.Config.Labels.WALLET_PUBLIC}}' $TARGET_IMAGE)\n\nTARGET_IMAGE_SHA=$(docker inspect --format='{{index (split (index .RepoDigests 0) \"@\") 1}}' $TARGET_IMAGE)\n\ndocker run --rm teamgosh/sign-cli check \\\n    -n &lt;blockchain_network e.g. https://gra01.net.everos.dev&gt; \\\n    $WALLET_PUBLIC \\\n    $TARGET_IMAGE_SHA\n</code></pre> <p>NOTE: Anyone who has the image can validate it. The image has label WALLET_PUBLIC and image's sha256 also publicly available.</p> <p>Additionally, signer tool can deploy a proof contract to GOSH blockchain that will be publicly available to all wanting to verify the image they pull from dockerhub.</p>"},{"location":"working-with-gosh/build-and-sign-images/#examples","title":"Examples","text":"<p>Publisher example</p>"},{"location":"working-with-gosh/docker-extension/","title":"Docker Extension","text":"<p>GOSH Docker Extension implements GOSH repository management and image verification as the newest feature of Docker - a Docker Extension.</p> <p>You will be able to create your GOSH account and Decentralized Autonomous Organization (DAO), set up and manage repositories through a graphical interface directly in Docker Desktop. Repositories stored in GOSH can then be interacted with like any regular remote repository, with a few small configurations to git, making decentralized code management easily available to anyone.</p> <p>Images built directly from code stored in GOSH can be verified as GOSH-sourced in the Docker Extension, ensuring security of the software supply chain. You will always know what code specifically is running in your containers, and that none of it was tampered with during build.</p>"},{"location":"working-with-gosh/docker-extension/#installation","title":"Installation","text":"<p>Get the latest Docker Desktop (4.8.0 or later), which supports extensions.</p> <p>Launch the Desktop, go to the Extensions section, and click Add Extensions.</p> <p></p> <p>Select and install GOSH extension on the marketplace.</p>"},{"location":"working-with-gosh/docker-extension/#create-account","title":"Create account","text":"<p>Open the GOSH verified images extension in Docker Desktop.  If you have a GOSH account, then enter your own one seed phrase, if not, you can create it by clicking on the link app.gosh.sh.</p> <p></p> <p>To get started with GOSH, you need an active Github-account.</p> <p>Click Create account</p> <p></p> <p>After click Authorize gosh-sh</p> <p></p> <p>In the list of organizations received from Github, click on the organization</p> <p></p> <p>and select repositories for upload into GOSH</p> <p></p> <p>Do this for each organization for which you want to upload repositories to GOSH.</p> <p>Danger</p> <p>After registering on GOSH you will not be able to return to this step in this release.</p> <p>This will be available later</p> <p>Info</p> <p>If you want other GOSH users to be able to find you by your email, give permission.</p> <p>Then click Upload</p> <p></p> <p>\u200bIf you are familiar with blockchain, you know what to do with a seed phrase.</p> <p>If you're new to blockchain, all you need to know, is that this is the key to your account and all your assets on GOSH. Your public key, which can identify you on the blockchain and the secret key you'll use to sign your actions can always be calculated from your seed phrase.</p> <p>To create the GOSH-account, the seed phrase will be generated for you.</p> <p></p> <p>Danger</p> <p>Write your seed phrase down and store it somewhere safe, and never share it with anyone. Avoid storing it in plain text or screenshots, or any other non-secure way. If you lose it, you lose access to your assets. Anyone who gets it, gets full access to your assets.</p> <p>Info</p> <p>Your seed phrase will be used to log into GOSH.</p> <p>Once you have written down your seed phrase, click Continue.</p> <p>Then choose a short nickname or create a new one and click Create account.</p> <p>Warning</p> <p>The Usernames must contain only Latin letters, numbers, hyphen, underscore character <code>( a...z, 0...9, -, _ )</code></p> <p></p> <p>Info</p> <p>When the repositories are uploaded, a notification will be sent to your email.</p> <p>Follow the link in the email.</p> <p></p> <p>To log into GOSH open the GOSH verified images extension in Docker Desktop and enter the saved seed phrase and click Sign in.</p> <p></p> <p>GOSH will ask you to set up a PIN code:</p> <p></p> <p>And unlock with PIN code.</p> <p>Once done, you will be logged into GOSH.</p> <p>Info</p> <p>The GOSH DAO Bot will be a member of your organization. In the future, it will track changes in your repositories on Github and synchronize them with GOSH.</p> <p>The Bot can be removed from the DAO members by voting. But then there will be no automatic synchronization of repositories in GOSH if they have been changed in Github.</p>"},{"location":"working-with-gosh/docker-extension/#create-organization","title":"Create Organization","text":"<p>The Organizations page will open after your account is created.</p> <p>Click New organization button in the Organizations section.</p> <p></p> <p>\u200bInput Organization name and members.</p> <p>Warning</p> <p>The Organizations name must contain only Latin letters, numbers, hyphen, underscore character <code>( a...z, 0...9, -, _ )</code></p> <p>The first mandatory member is the creator, identified by their username.</p> <p>The second member is the GOSH DAO Bot. It will synchronize repositories with github on GOSH.</p> <p>Any other members can be added at creation - just enter the username of each member in new line.</p> <p>At any later time the list of members can be expanded by voting.</p> <p>Click Create organization.</p> <p></p> <p>\u200bOnce created, your organization will appear in the organization list. Click on it to continue.</p> <p></p>"},{"location":"working-with-gosh/docker-extension/#create-repository","title":"\u200bCreate Repository","text":"<p>To create a repository in your organization click Create in the Repositories section.</p> <p></p> <p>Enter repository name and click Create repository.</p> <p>Warning</p> <p>The repository name must contain only Latin letters, numbers, hyphen, underscore character <code>( a...z, 0...9, -, _ )</code></p> <p></p>"},{"location":"working-with-gosh/docker-extension/#create-branch","title":"Create Branch","text":"<p>Repository is created with default main branch. To create another branch, click on the branches counter.</p> <p></p> <p>Select the branch to be forked, enter new branch name, and click\u200b Create branch.</p> <p>Warning</p> <p>The branch name must contain only Latin letters, numbers, hyphen, underscore character <code>( a...z, 0...9, -, _ )</code></p> <p></p> <p>Once the branch is created, it will appear in the branches list.</p> <p></p> <p>Switch to it via drop down list.</p> <p></p>"},{"location":"working-with-gosh/docker-extension/#create-file","title":"Create File","text":"<p>To create file, click Add file button.</p> <p></p> <p>Enter file contents and name. MD syntax is supported for preview.</p> <p></p> <p>Once done, scroll down to Commit data, enter commit info and click Commit changes button.</p> <p></p> <p>Commit status will be displayed below.</p> <p></p> <p>If the branch you are working in requires no vote to commit to, the changes will be commited immediately/ Otherwise a DAO vote will be initiated.</p>"},{"location":"working-with-gosh/docker-extension/#create-pull-request","title":"Create Pull Request","text":"<p>Click on the Pull requests tab and set up the pull request: what branch to merge from and to.</p> <p></p> <p>View the diff, scroll down to Commit data, enter details and click Commit changes.</p> <p></p> <p>Info</p> <p>When merging into the main branch, and in some other cases (depending on DAO setup), a DAO proposal will be initiated by trying to commit.</p> <p>Organization Tokens have to be sent to the DAO Soft Majority Vote contract to start a proposal for DAO members to vote on.</p>"},{"location":"working-with-gosh/docker-extension/#voting-in-smv-soft-majority-vote","title":"Voting in SMV (Soft Majority Vote)","text":"<p>Actions that require a DAO vote, such as merging into main, are performed by creating a proposal.</p> <p>To create a proposal, or to vote for a proposal someone else created, some of your tokens need to be allocated to SMV (once the proposal is completed), you can get them back.</p> <p>For example, to merge into main, create a pull request from some other branch. A proposal will be generated and will appear on the Events page.</p> <p></p> <p>Open the proposal and review the contents.</p> <p></p> <p>The voting period is indicated on the proposal page. This is the time allotted for voting. Unless a decisive majority of &gt;50% is achieved early, votes will be counted at the end of this period.</p> <p>Voting statistics are located under the status Running. The green and red counters indicate how many tokens have been used at the moment to vote for and against the proposal.</p> <p>The green indicator in the top right corner means that the SMV smart contracts are not currently processing any new votes. It turns red when the SMV contracts are busy.</p> <p>Once you have made a decision, input the amount of tokens, select Approve or Reject and click Vote for proposal. Vote registration can take a bit of time.</p> <p>Info</p> <p>As per the rules of Soft Majority Voting, to have a proposal approved early, you need at least 50% of the total supply of tokens in the repository + 1 token used to vote for the proposal.</p> <p>For example, in a repository with two members, where the total supply of tokens is 200, 101 token needs to be used to instantly approve a proposal. Thus with every member holding 100 tokens a proposal can never be instantly completed without the participation of members other than the proposal's author.</p> <p>On the other hand, so as not to depend on all members of an organization to vote, soft majority vote will complete with an approval at the end of the voting period, if 10% of the total token supply were used to vote for, and no one voted against.</p> <p>The more tokens are sent against the proposal, the higher the approving amount needs to be (up to 50% of the total supply  + 1 token) for the proposal to pass.</p> <p>Other members of the Organization, who have transferred their tokens to SMV, will be able to vote for the proposal on this page in their own accounts.</p> <p>Info</p> <p>Currently, even in organizations with a single member, voting still takes place when a proposal is created. 51 tokens are needed to approve a proposal in such a repository.</p> <p>Once a majority has been reached early, or the voting period ended and the soft majority vote result was decided, the proposal completes and the proposed action is performed.</p> <p></p>"},{"location":"working-with-gosh/docker-extension/#view-public-key","title":"View Public Key","text":"<p>A user needs to know their public key, for example, when joining an organization.</p> <p>To view your public key go to the main page of your account and click Settings.</p> <p>Danger</p> <p>Avoid storing your private key and seed phrase in plain text or screenshots, or any other non-secure way. If you lose it, you lose access to your assets. Anyone who gets it, gets full access to your assets.</p> <p></p>"},{"location":"working-with-gosh/docker-extension/#add-members-to-organization","title":"Add Members to Organization","text":"<p>Go to Organization Settings to the Members tab to manage your organization.</p> <p>To add member enter the username of each candidate from a new line and click Add members button.</p> <p></p>"},{"location":"working-with-gosh/docker-extension/#whats-next","title":"What's next?","text":"<p>Set up Git Remote Helper and continue working with your repository.</p> <p>You'll need your wallet credentials. Go to the main page of your account and click Settings. Scroll down and copy them.</p> <p></p> <p>To view the command to clone your repo, click the Clone button on your repo page.</p> <p></p>"},{"location":"working-with-gosh/docker-extension/#update-docker-extension","title":"Update Docker Extension","text":"<p>When you need to update the GOSH verified images extension in Docker Desktop, you will see an orange indicator.</p> <p>To update the extension, go to the menu and select Manage </p> <p>click Update</p> <p></p> <p>After downloading the update, click Open</p> <p></p>"},{"location":"working-with-gosh/git-remote-helper/","title":"Git Remote Helper","text":"<p>Git Remote Helper (this is a standard mechanism for working with non-standard code storages) is a <code>git-client helper</code> to interact with remote repositories hosted on the GOSH blockchain. </p>"},{"location":"working-with-gosh/git-remote-helper/#installation","title":"Installation","text":""},{"location":"working-with-gosh/git-remote-helper/#install-helper-using-the-installation-script","title":"Install helper using the installation script","text":"<p>If you have macOS or Linux, you can use this installation method.</p> <pre><code>wget -O - \\\n  https://raw.githubusercontent.com/gosh-sh/gosh/dev/install.sh \\\n  | bash -s\n</code></pre> <p>Checking the installation results.</p>"},{"location":"working-with-gosh/git-remote-helper/#install-helper-using-the-installation-package","title":"Install helper using the installation package","text":"<p>If you have a Debian-based system, use the installation from the package:</p> <pre><code>wget https://github.com/gosh-sh/gosh/releases/download/4.1.20/git-remote-gosh-amd64.deb\n</code></pre> <p>then</p> <pre><code>sudo dpkg -i git-remote-gosh-amd64.deb\n</code></pre> <p>Checking the installation results.</p> <p>If you have Windows, you can use the installation methods below.</p>"},{"location":"working-with-gosh/git-remote-helper/#install-helper-from-binary-releases","title":"Install helper from binary releases","text":"<ol> <li> <p>Follow the <code>link</code> and download the version of the Git Remote Helper for the required operating system (macOS, Linux, Windows).</p> </li> <li> <p>Extract files from tar-file</p> <p>(e.g. for Linux x64):</p> <pre><code>tar xvf git-remote-gosh-linux-amd64.tar\n</code></pre> </li> <li> <p>Move binary files to any searchable path</p> <p>(e.g. /usr/local/bin):</p> <pre><code>mv git-remote-gosh /usr/local/bin\n</code></pre> <pre><code>mv git-remote-gosh_v?_0_0 /usr/local/bin\n</code></pre> <p>and move dispatcher.ini to ~/.gosh/ folder:</p> <pre><code>mkdir ~/.gosh || mv dispatcher.ini ~/.gosh/\n</code></pre> </li> </ol> <p>Checking the installation results.</p>"},{"location":"working-with-gosh/git-remote-helper/#install-helper-from-source","title":"Install helper from source","text":"<ol> <li> <p>Prerequisites:</p> <ul> <li>Rust v1.66+</li> <li>Protobuf Compiler</li> <li><code>git</code></li> <li><code>make</code></li> <li><code>gcc</code></li> <li> <p><code>openssl</code></p> <p>Note</p> <p>For Windows users:</p> <p>make sure that the appropriate Perl version is installed for your build environment.</p> </li> </ul> </li> <li> <p>Clone <code>gosh</code> repository.</p> </li> <li> <p>Go to the <code>gosh</code> directory</p> <pre><code>  cd gosh\n</code></pre> <p>Then build all the necessary components:</p> <pre><code>  cd v1_x/git-remote-gosh &amp;&amp; make install\n</code></pre> <pre><code>  cd v2_x/git-remote-gosh &amp;&amp; make install\n</code></pre> <pre><code>  cd v3_x/git-remote-gosh &amp;&amp; make install\n</code></pre> <pre><code>  cd v4_x/git-remote-gosh &amp;&amp; make install\n</code></pre> <pre><code>  cd gosh-dispatcher &amp;&amp; make install\n</code></pre> <p>Info</p> <p>After building all the components, the finished binary files will be located in the <code>~/.cargo/bin</code> directory.</p> <p>You need to create a configuration file for the Git Remote Helper: <code>~/.gosh/dispatcher.ini</code></p> <p>with the following content:</p> <pre><code>  git-remote-gosh_v1_0_0\n</code></pre> <pre><code>  git-remote-gosh_v2_0_0\n</code></pre> <pre><code>  git-remote-gosh_v3_0_0\n</code></pre> <pre><code>  git-remote-gosh_v4_0_0\n</code></pre> </li> </ol>"},{"location":"working-with-gosh/git-remote-helper/#verifying-the-installation-result","title":"Verifying the installation result","text":"<p>You can check the correctness of the configuration file by running the command:</p> <pre><code>git-remote-gosh dispatcher_ini\n</code></pre> <p>As a result, you will see the following:</p> <p></p> <p>Run the following command to make sure it's available:</p> <pre><code>which git-remote-gosh\n</code></pre> <p>If the Git Remote Helper is not available, then add path with <code>git-remote-gosh</code></p> <p>for availability via <code>$PATH</code>:</p> <pre><code>export PATH=~/.gosh:$PATH\n</code></pre>"},{"location":"working-with-gosh/git-remote-helper/#setup-user-account","title":"Setup user account","text":"<p>When creating your account in GOSH Web or Docker extension you received a GOSH wallet address and keys.</p> <p>To be able to push to GOSH repositories, you need to set up these credentials for Git Remote Helper.</p> <p>The Git Remote Helper expects that the wallet credentials are in the file <code>~/.gosh/config.json</code> or in the file specified in the environment variable <code>GOSH_CONFIG_PATH</code>,</p> <p>for example:</p> <pre><code>{\n  \"primary-network\": \"mainnet\",\n  \"networks\": {\n    \"mainnet\": {\n      \"user-wallet\": {\n        \"profile\": \"USERNAME\",\n        \"pubkey\": \"655b120c996b4f69c686cb3b769fbdfa0141006ce6a88dc012bf323c30265924\",\n        \"secret\": \"6bdc38c0ecd6f74399f6b8ff2486f0e2abb32fca712caf3e4a47ef4a2634c4e8\"\n      },\n      \"endpoints\": [\n        \"https://bhs01.network.gosh.sh\",\n        \"https://eri01.network.gosh.sh\",\n        \"https://gra01.network.gosh.sh\"\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"working-with-gosh/git-remote-helper/#use-gosh-as-remote","title":"Use GOSH as remote","text":"<p>For correct usage of the helper you should refer to remote in the following form:</p> <pre><code>gosh://SYSTEM_CONTRACT_ADDRESS/DAO_NAME/REPO_NAME\n</code></pre>"},{"location":"working-with-gosh/git-remote-helper/#set-remote-for-existing-local-repository","title":"Set remote for existing local repository","text":"<p>Copy the URL to configure the remote from the web interface, after creating a repository on GOSH.</p> <p></p> <p>Info</p> <p>The address of the System Contract depends from the GOSH version of contracts.</p> <p>for example setup for version 3:</p> <pre><code>git remote add origin gosh://0:8b1cbcd8b08a6c384e0db0d3513898d36203fced3e141a7f6b99cc580738fc22/my-DAO/my-repo\n</code></pre>"},{"location":"working-with-gosh/git-remote-helper/#clone-repository","title":"Clone repository","text":"<pre><code>git clone gosh://0:8b1cbcd8b08a6c384e0db0d3513898d36203fced3e141a7f6b99cc580738fc22/my-DAO/my-repo\n</code></pre>"},{"location":"working-with-gosh/git-remote-helper/#ever-sdk-protocol","title":"Ever SDK protocol","text":"<p>By default, the SDK in Git Remote Helper uses the WebSocket protocol. If for some reason this does not suit you (for example, you are using Alpine Linux), then set the environment variable <code>GOSH_PROTO</code> to <code>http</code></p> <pre><code>export GOSH_PROTO=http\n</code></pre>"},{"location":"working-with-gosh/gosh-ai/","title":"GOSH.AI","text":""},{"location":"working-with-gosh/gosh-ai/#overview","title":"Overview","text":"<p>GOSH.AI will help you simplify the workflow of writing code.</p> <p>Info</p> <p>GOSH.AI only supports code for asynchronous Solidity at the moment</p> <p>Now one person with technical knowledge can manage and deliver complex software in very little time.</p> <p>GOSH.AI will create all project files in the repository on the blockchain and write code, tests and deploy scripts.</p> <p>The generated code is immutable, has timestamps and is stored in a decentralized way.</p>"},{"location":"working-with-gosh/gosh-ai/#working-with-goshai","title":"Working with GOSH.AI","text":"<p>Start your acquaintance with GOSH.AI from this page</p> <p>Click the button Try GOSH AI</p> <p></p> <p>If you already have a GOSH account, then go here:</p> <p>If you are a new user, follow these instructions:</p>"},{"location":"working-with-gosh/gosh-ai/#start-for-new-users","title":"start for new users","text":"<p>If you haven't a GOSH account, then click Create account</p> <p></p> <p>To start with GOSH.AI we need a Spec.md file with a description of your project.</p> <p>You can upload and edit later it by clicking on Attach Spec.md file</p> <p>or create in the form that opens</p> <p></p> <p>Then a form for sending an prompt is activated on the right. Enter the name of the repository that will be created after processing the request.</p> <p>You can also specify an email address (an email will be sent to it after the repository is downloaded)</p> <p></p> <p>After sending the prompt, the bot GOSH.AI will create the DAO for you, where your repository will be uploaded.</p> <p>You can go to your GOSH.AI organization by clicking on it</p> <p></p> <p>Create a PIN code to log in to GOSH.AI</p> <p></p> <p>After uploading the repository, you can continue working with it</p> <p></p>"},{"location":"working-with-gosh/gosh-ai/#start-for-gosh-users","title":"start for GOSH users","text":"<p>If you are a GOSH user, then click Log in with GOSH</p> <p></p> <p>and enter your seed phrase</p> <p></p> <p>To start with GOSH.AI we need a Spec.md file with a description of your project.</p> <p>You can upload and edit later it by clicking on Attach Spec.md file</p> <p>or create in the form that opens</p> <p></p> <p>Then a form for sending an prompt is activated on the right.</p> <p>Select an organization or create new</p> <p></p> <p>and enter the name of the repository that will be created after processing the request.</p> <p>Then click Develop code</p> <p></p> <p>After sending the prompt, the bot GOSH.AI will create the DAO for you, where your repository will be uploaded.</p> <p>You can go to your GOSH.AI organization by clicking on it</p> <p></p> <p>Create a PIN code to log in to GOSH.AI</p> <p></p> <p>After uploading the repository, you can continue working with it</p> <p></p>"},{"location":"working-with-gosh/gosh-ai/#working-with-the-result","title":"working with the result","text":"<p>After creating and processing the repository, you can enter into it and see what happened</p> <p>You can view the received files, leave comments on the files.</p> <p>After reviewing the files, send them to GOSH.AI for processing click by Finish review, request changes</p> <p></p> <p>after processing the comments, GOSH.AI creates a proposal with the modified files</p> <p>You can view the event on the DAO tab:</p> <p></p> <p>Check out the results of GOSHA's work</p> <p></p> <p>If you are not satisfied with the result of the work, then you can comment on the diffs</p> <p></p> <p>in the section Your vote select Reject and write a comment on the vote</p> <p>Warning</p> <p>the voting comment must contain a certain number of characters.</p> <p>then click Send vote</p> <p></p> <p>GOSH.AI will make changes to the code taking into account the comments.</p> <p>Info</p> <p>You can return to the repository, leave comments and create suggestions until you are satisfied with the result.</p> <p>When the result of GOSH.AI work fully satisfies everyone, you can accept proposal</p> <p></p> <p>After accepting the proposal, you will receive a ready-made code.</p>"},{"location":"working-with-gosh/sync/","title":"GOSH GitHub Sync","text":"<p>GOSH GitHub Sync is an easy way to enable GOSH DAOs to work side by side with GitHub Repositories.</p> <p>You can build Consensus around your code and organization through DAOs on GOSH while continuing to use GitHub\u2019s familiar development tools.</p>"},{"location":"working-with-gosh/sync/#introduction","title":"Introduction","text":"<p>A year ago we introduced the Login with GitHub option to easily migrate your repositories to GOSH when you sign up. Now we are enhancing this capability enabling continuous synchronization of your GitHub and GOSH repositories.</p> <p>Synchronize your GitHub repositories with GOSH, and work with both platforms side by side. Changes in a GitHub repository appear in GOSH, offering both the benefits from GitHub features, convenience, and efficiency; while not compromising the decentralization of code and governance, as assured by GOSH.</p>"},{"location":"working-with-gosh/sync/#how-it-works","title":"How it works","text":"<p>Github-actions are triggered by changes in the github repository and execute their script. User\u2019s changes will be pushed automatically to GOSH. The script will clone the repository, and its history, and push these branch changes to the matching branch in GOSH.</p>"},{"location":"working-with-gosh/sync/#how-to-set-it-up","title":"How To Set It Up","text":""},{"location":"working-with-gosh/sync/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Create a separate bot account in GitHub, and register this bot on GOSH</p> </li> <li> <p>Add this bot to the DAO with the repository you want to synchronize</p> </li> <li> <p>GitHub Sync requires CONFIG_JSON and GOSH_URL set up</p> </li> </ul> <p>Info</p> <p>You need only a single bot for the whole DAO</p>"},{"location":"working-with-gosh/sync/#set-up-config_json","title":"Set up CONFIG_JSON","text":"<ul> <li>You need to copy <code>config.json</code> content under Show</li> </ul> <ul> <li>Go to repository settings in the Secrets and variables in GitHub, and press New repository secret, and add credentials</li> </ul> <p>Info</p> <p>You can use <code>CONFIG_JSON</code> once for your whole organization</p>"},{"location":"working-with-gosh/sync/#set-up-gosh_url","title":"Set up GOSH_URL","text":"<p>GOSH_URL is a variable in github-actions. It must point to the GOSH repository (the one we sync changes to)</p> <p></p> <p>Click on New repository variable:</p> <p></p> <p>Set value of the <code>GOSH_URL</code>:</p> <p></p>"},{"location":"working-with-gosh/sync/#set-up-github-actions","title":"Set up github-actions","text":"<p>Enable github-actions by creating a <code>/.github/workflows</code> folder in your GitHub repository. You can also create it in your user interface and copy the content below, and GitHub will create the folder for you automatically. Create a <code>gosh-sync.yaml</code> file inside, in this aforementioned folder and add this content:</p> <pre><code>name: Sync with GOSH\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n\n    steps:\n      -\n        name: Checkout\n        uses: actions/checkout@v4\n        with:\n          # Only a single commit is fetched by default, for the ref/SHA that\n          # triggered the workflow. Set fetch-depth: 0 to fetch all history for\n          # all branches and tags.\n          fetch-depth: 0\n\n      - name: Sync\n        env:\n          CONFIG_JSON: ${{ secrets.CONFIG_JSON }}\n          GOSH_URL: ${{ vars.GOSH_URL }}\n          GOSH_TMP_BRANCH: github_${{ github.ref_name }}\n        run: |\n          # install GOSH Git Remote plugin\n          wget -O - https://raw.githubusercontent.com/gosh-sh/gosh/dev/install.sh | bash -s\n          export PATH=\"$HOME\"/.gosh:\"$PATH\"\n\n          # set user secrets\n          echo \"$CONFIG_JSON\" &gt;~/.gosh/config.json\n\n          # sync github -&gt; gosh\n          git remote add gosh $GOSH_URL\n          git switch -C $GOSH_TMP_BRANCH\n          git push -vv gosh\n</code></pre> <p>After this is done, all of the changes pushed to GitHub will be seen on GOSH (except the branches\u2019 names). Starting from this first commit onwards, every change to your GitHub repository will be mirrored to GOSH. </p> <p>For example</p> <p>If there were changes in a main branch in GitHub, these changes will appear in the github_main branch in GOSH and once DAO decides to accept those changes they can create a proposal to merge changes from the github_main branch into the main, inside GOSH.</p>"},{"location":"working-with-gosh/verify-images-in-docker-extension/","title":"Verify Images in Docker Extension","text":"<p>Once you have pulled a GOSH image someone else built and uploaded to dockerhub, you can verify, that it was build from the exact code on GOSH that it claims to be built from.</p> <p>To do that, go to Containers Tab in Docker Extension.</p> <p></p> <p>Your containers and their hashes are listed on this tab.</p> <p>Scroll left to see the GOSH repository link it claims to be build from.</p> <p>Click Validate.</p> <p></p> <p>GOSH docker extension will read the hash of the container, rebuild the container from the specified repository, compare resulting hash and report whether the hashes match.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/account/","title":"Account","text":"<p>To manage your projects in a decentralized way using the DAO, you will need to organize all the necessary components in a Repository on GOSH.</p> <p>But to get started, you need to create your GOSH Account.</p>"},{"location":"working-with-gosh/gosh-web/account/#create-account","title":"Create Account","text":"<p>To start registering on GOSH, simply visit the GOSH website and click Create account:</p> <p></p> <p>Use one of the suggested methods:</p> <p></p>"},{"location":"working-with-gosh/gosh-web/account/#with-github","title":"with GitHub","text":"<p>Use your Github account to sign up for GOSH.</p> <p>To do this,enter your username or email address and password and click Sign in button:</p> <p></p> <p>and complete the authentication.</p> <p>Info</p> <p>The special GOSH DAO Bot will help with registration in GOSH. It will deploy your DAO and upload your selected repositories to GOSH.</p> <p>In the list of organizations received from Github, select the organization from which you want to make a DAO on GOSH</p> <p></p> <p>and then select repositories for upload into GOSH.</p> <p></p> <p>Do this for each organization for which you want to upload repositories to GOSH.</p> <p>Danger</p> <p>After registering on GOSH you will not be able to return to this step in this release.</p> <p>This will be available later</p> <p>Info</p> <p>If you want other GOSH users to be able to find you by your email, give permission.</p> <p>Then click Upload</p> <p></p> <p>\u200bIf you are familiar with blockchain, you know what to do with a seed phrase.</p> <p>If you're new to blockchain, all you need to know is that this is the key to your Account and all your assets on GOSH. Your public key, which can identify you on the blockchain and the secret key you'll use to sign your actions can always be calculated from your seed phrase.</p> <p>To create the GOSH Account, the seed phrase will be generated for you. If you already have the GOSH Account, click Clear and enter your own one seed phrase.</p> <p>Info</p> <p>Your seed phrase will be used to log into GOSH.</p> <p>Danger</p> <p>Write your seed phrase down and store it somewhere safe, and never share it with anyone. Avoid storing it in plain text or screenshots, or any other non-secure way. If you lose it, you lose access to your assets. Anyone who gets it, gets full access to your assets.</p> <p>Once you have written down your seed phrase, click Continue.</p> <p></p> <p>Then choose your username in GOSH. This is your unique cryptographic identifier in GOSH. </p> <p>Danger</p> <p>Please note that after creating your username it will be impossible to change it in the future.</p> <p>if your username is already taken, please choose another one.</p> <p>Warning</p> <p>The username must contain only Latin letters, numbers, hyphen, underscore character <code>( a...z, 0...9, -, _ )</code></p> <p>And click Create account.</p> <p></p> <p>When entering the GOSH will ask you to set up a PIN code:</p> <p>Info</p> <p>Set a new PIN code for each new session.</p> <p></p> <p>And unlock with PIN code.</p> <p>Warning</p> <p>If the name of the organization or repository already exists, you will receive the message. Change the name, click save changes and confirm the action with a pin code.</p> <p></p> <p>The Organizations page will open after your Account is created.</p> <p></p> <p>Info</p> <p>When the repositories are uploaded, a notification will be sent to your email.</p> <p>Follow the link in the letter.</p> <p></p> <p>Enter the saved seed phrase and click Sign in.</p> <p></p> <p>Also set up a PIN code and unlock with PIN code.</p> <p>You can also ensure continuous synchronization of your GitHub and GOSH repositories. To do this you can use GOSH GitHub Sync.</p>"},{"location":"working-with-gosh/gosh-web/account/#with-google","title":"with Google","text":"<p>You can use your Google account to sign up for GOSH click Sign in with Google</p> <p>Then,enter your email address or phone number and click Next button:</p> <p></p> <p>Confirm the selection with a password and proceed to the next step by clicking Next</p> <p></p> <p>Specify the email address that is convenient for you to work with GOSH.</p> <p>Then choose your username in GOSH. This will be your unique cryptographic identifier in GOSH.</p> <p>Danger</p> <p>Please note that after creating your username it will be impossible to change it in the future.</p> <p>if your username is already taken, please choose another one.</p> <p>Warning</p> <p>The username must contain only Latin letters, numbers, hyphen, underscore character <code>( a...z, 0...9, -, _ )</code></p> <p>then click Continue</p> <p></p> <p>On the next step, you will be offered the generated seed phrase.</p> <p>\u200bIf you are familiar with blockchain, you know what to do with a seed phrase.</p> <p>If you're new to blockchain, all you need to know is that this is the key to your Account and all your assets on GOSH. Your public key, which can identify you on the blockchain and the secret key you'll use to sign your actions can always be calculated from your seed phrase.</p> <p>To create the GOSH Account, the seed phrase will be generated for you. If you already have the GOSH Account, click Clear and enter your own one seed phrase.</p> <p>Info</p> <p>Your seed phrase will be used to log into GOSH.</p> <p>Danger</p> <p>Write your seed phrase down and store it somewhere safe, and never share it with anyone. Avoid storing it in plain text or screenshots, or any other non-secure way. If you lose it, you lose access to your assets. Anyone who gets it, gets full access to your assets.</p> <p>Once you have written down your seed phrase, check the box and click Continue</p> <p></p> <p>Then, please enter the required words from your phrase, separated by a space, to make sure that it is spelled correctly, and click Create Account</p> <p></p> <p>When entering the GOSH will ask you to set up a PIN code:</p> <p>Info</p> <p>Set a new PIN code for each new session.</p> <p></p> <p>And unlock with this PIN code.</p> <p>Congratulations, your GOSH account has been created.</p> <p>It remains to create a your first DAO. To do this, click on Create DAO and complete</p> <p></p> <p>On the page that opens, click on your DAO to open. A description of further work with DAO can be seen here</p> <p></p> <p>You can synchronize your GitHub repositories with GOSH, which allows you to work with both platforms side by side. To do this you can use GOSH GitHub Sync.</p>"},{"location":"working-with-gosh/gosh-web/account/#with-linkedln","title":"with Linkedln","text":"<p>Use your Linkedln account to sign up for GOSH.</p> <p>To do this,enter your email address and password and click Sign in button:</p> <p></p> <p>Click on the Allow button to grant permission for the use of your data</p> <p></p> <p>Specify the email address that is convenient for you to work with GOSH.</p> <p>Then choose your username in GOSH. This will be your unique cryptographic identifier in GOSH.</p> <p>Danger</p> <p>Please note that after creating your username it will be impossible to change it in the future.</p> <p>if your username is already taken, please choose another one.</p> <p>Warning</p> <p>The username must contain only Latin letters, numbers, hyphen, underscore character <code>( a...z, 0...9, -, _ )</code></p> <p>then click Continue</p> <p></p> <p>On the next step, you will be offered the generated seed phrase.</p> <p>\u200bIf you are familiar with blockchain, you know what to do with a seed phrase.</p> <p>If you're new to blockchain, all you need to know is that this is the key to your Account and all your assets on GOSH. Your public key, which can identify you on the blockchain and the secret key you'll use to sign your actions can always be calculated from your seed phrase.</p> <p>To create the GOSH Account, the seed phrase will be generated for you. If you already have the GOSH Account, click Clear and enter your own one seed phrase.</p> <p>Info</p> <p>Your seed phrase will be used to log into GOSH.</p> <p>Danger</p> <p>Write your seed phrase down and store it somewhere safe, and never share it with anyone. Avoid storing it in plain text or screenshots, or any other non-secure way. If you lose it, you lose access to your assets. Anyone who gets it, gets full access to your assets.</p> <p>Once you have written down your seed phrase, check the box and click Continue</p> <p></p> <p>Then please input the requested words from your phrase to ensure it is written correctly and click Create account</p> <p></p> <p>When entering the GOSH will ask you to set up a PIN code:</p> <p>Info</p> <p>Set a new PIN code for each new session.</p> <p></p> <p>And unlock with this PIN code.</p> <p>Congratulations, your GOSH account has been created.</p> <p>It remains to create a DAO. To do this, click on Create DAO and complete</p> <p></p> <p>On the page that opens, click on your DAO to open. A description of further work with DAO can be seen here</p> <p></p> <p>You can synchronize your GitHub repositories with GOSH, which allows you to work with both platforms side by side. To do this you can use GOSH GitHub Sync.</p>"},{"location":"working-with-gosh/gosh-web/account/#view-public-key","title":"View Public Key","text":"<p>A user needs to know their public key, for example, when joining an organization.</p> <p>To view your public key go to the main page of your Account and click Settings.</p> <p>Danger</p> <p>Avoid storing your private key and seed phrase in plain text or screenshots, or any other non-secure way. If you lose it, you lose access to your assets. Anyone who gets it, gets full access to your assets.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/create-dao/","title":"Create DAO","text":"<p>DAO - (Decentralized Autonomous Organization) is a tool that enables developers to build on GOSH in a way that is decentralized, secure, and scalable. </p> <p>Warning</p> <p>To create a DAO, you must have an active GOSH account.</p> <p>Info</p> <p>Your first DAO is created during sign up on GOSH.</p> <p>To create a new DAO go to the GOSH web and click Sign In</p> <p></p> <p>Enter the saved seed phrase and click Sign in.</p> <p></p> <p>Also set up a PIN code and unlock with it.</p> <p>To click Create new DAO button on the page that opens</p> <p></p> <p>To fill out all the required fields on the page that opens:</p> <p></p> <ul> <li> <p>New organization name</p> <p>Warning</p> <p>The Organizations name must contain only Latin letters, numbers, hyphen, underscore character <code>( a...z, 0...9, -, _ )</code></p> </li> <li> <p>Organization picture</p> <p>The icon will be generated automatically.</p> </li> <li> <p>Theme tags</p> <p>You can add up to 3 tags separated by spaces.  According to them, GOSH users will be able to find your DAO.</p> </li> <li> <p>Short description</p> <p>A short description that can be seen on the DAO tab under the heading.</p> <p>The extended description can be added to the Readme file into _index system repository from the Overview page after creating the DAO.</p> </li> <li> <p>Total supply</p> <p>You also need to enter the number of tokens that will be issued for this DAO.</p> <p>The maximum value of the total supply can be the number 2^128.</p> </li> <li> <p>Allow mint</p> <p>This is a permission to emission DAO tokens. It is enabled by default.</p> <p>In the future, it will be possible to disable the emission of DAO tokens through proposal and voting in the Settings section.</p> <p>Warning</p> <p>If you uncheck this option, the number of tokens issued for this DAO will be capped to the number entered during the initial setup</p> </li> </ul> <p>Click Create organization.</p> <p>The DAO tab will open after its creation.</p>"},{"location":"working-with-gosh/gosh-web/dao-overview/","title":"DAO Overview","text":"<p>All information about your DAO and its activities will be displayed here.</p> <p></p> <p>Information about DAO assets is displayed on the right.</p>"},{"location":"working-with-gosh/gosh-web/dao-overview/#dao-total-supply","title":"DAO total supply","text":"<p>the total issue of tokens of this DAO.</p>"},{"location":"working-with-gosh/gosh-web/dao-overview/#dao-reserve","title":"DAO reserve","text":"<p>unallocated tokens.</p> <p>Push on the Send button, you will create an proposal to transfer tokens from the DAO reserve to the DAO member.</p> <p>Push on the Mint button, you will create an proposal to mint additional tokens for this DAO.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-overview/#your-wallet-balance","title":"Your wallet balance","text":"<p>the amount of tokens you have in this DAO.</p> <pre><code>!!! info\n    When creating a DAO, 20 tokens from the DAO reserve will be issued to your wallet.\n\nPush on the **SEND** button, you will to transfer your tokens to the DAO reserve or to the GOSH user.\n</code></pre>"},{"location":"working-with-gosh/gosh-web/dao-overview/#karma","title":"Karma","text":"<p>the amount of tokens (upper limit) within which a DAO member can vote. </p> <pre><code>It is assigned when accepted as a member of the DAO. This determines the reputation of the DAO member. The Karma can be changed only by voting.\n</code></pre> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-overview/#members","title":"Members","text":"<p>total number of DAO members.</p> <pre><code>From here you can also send an invitation to become a member of the DAO.\n&lt;!-- TODO --&gt;\n</code></pre> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-overview/#recent-proposals","title":"Recent proposals","text":"<p>Information and status of the recent proposals will be displayed  in this section.  Click on the name of the proposal you can go to the event page and vote.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-overview/#repositories","title":"Repositories","text":"<p>In the Repositories section, you can quickly find or create a repository.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-overview/#dao-system-repository","title":"DAO system repository","text":"<p>The _index is a DAO system repository that is created automatically.</p> <p>Info</p> <p>After creating the DAO, it will already contain  a text file with a brief description of your DAO, which you added in the settings earlier.</p> <p>To add a README for your DAO, go to the _index repository or follow the link in this section.</p> <p></p> <p>Make sure you are in the main branch and click Add file button.</p> <p></p> <p>Enter file contents and name.</p> <p></p> <p>You can use Preview if needed. MD syntax is supported for preview.</p> <p>After scroll down and enter commit info:</p> <ul> <li> <p>Commit description - you can add a description of your commit;</p> </li> <li> <p>Commit tags - this is a mutable pointer of the commit. You can add the tag to quickly go to this commit and see what has been done;</p> </li> </ul> <p></p> <ul> <li>Select a task - if you want to attach your commit to the solution of the Task, then select the desired task from the list;</li> </ul> <p></p> <ul> <li>and add Assigners, Reviewers and Managers if necessary.</li> </ul> <p></p> <p>If a Task has been selected, check the Create proposal box.</p> <p>And click Commit changes</p> <p></p> <p>After that a proposal to the pull request will be created.</p> <p></p> <p>When the proposal to the pull request is accepted, the description of the DAO will appear on the Overview tab.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-set-up/","title":"Settings","text":""},{"location":"working-with-gosh/gosh-web/dao-set-up/#dao-set-up","title":"DAO Set up","text":"<p>You can continue with the initial setup the DAO in the Settings tab.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-set-up/#tags","title":"Tags","text":""},{"location":"working-with-gosh/gosh-web/dao-set-up/#token-setup","title":"Token Setup","text":"<p>In the Token Setup section, you can create a proposal to ban the issue of tokens from this DAO by unchecking the box.</p> <p>Warning</p> <p>After the ban on the issue of DAO tokens, it will be impossible to allow the issue.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-set-up/#event-setup","title":"Event setup","text":"<p>In the Event setup section you can enable/disable the option to view the voting results before it ends.</p> <p>And also allow or prohibit discussion when working with proposals.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-set-up/#members-setup","title":"Members setup","text":"<p>In the Members setup section you can grant or deny external users the ability to request membership in this DAO.</p> <p></p> <p>Then add a comment on changing the settings for other members of the DAO and click Save changes and start proposal.</p> <p></p> <p>Info</p> <p>All settings and actions in the DAO will be performed the voting procedure.</p>"},{"location":"working-with-gosh/gosh-web/dao-set-up/#karma-tags","title":"Karma tags","text":""},{"location":"working-with-gosh/gosh-web/dao-set-up/#notifications","title":"notifications","text":""},{"location":"working-with-gosh/gosh-web/dao-set-up/#upgrade","title":"Upgrade","text":""},{"location":"working-with-gosh/gosh-web/dao-set-up/#basic-information","title":"Basic information","text":"<p>When a new version of contracts is released in GOSH, the user needs to upgrade their contracts.</p> <p>The upgrade is initiated by the proposal.</p> <p>Warning</p> <p>Make sure that the proposal for such an update has not yet been created.</p> <p>Info</p> <p>Complete all proposal before starting the upgrade. All uncompleted proposals will be rejected and will not be transferred to the upgraded version.</p> <p>You can see a message about the availability of a new version  and an invitation to update in the DAO.</p> <p>Depending on which version you currently have, choose the appropriate update method.</p> <p>It is recommended to upgrade to the latest version.</p> <p>Info</p> <p>All token holders after upgrading the DAO must transfer their tokens from previous versions.</p>"},{"location":"working-with-gosh/gosh-web/dao-set-up/#from-v-1-to-v-2","title":"from v. 1 to v. 2","text":"<p>You can switch to the Upgrade section from the new version message or go to the Settings tab.</p> <p></p> <p>Select the version you want to upgrade and click Create proposal for DAO upgrade:</p> <p></p> <p>You will be taken to the DAO tab with events.</p> <p></p> <p>After accepting the proposal, the procedure for updating your DAO will begin.</p> <p>Then you need to update all the Repositories.</p> <p>To do this, go to their tab and click Get repositories</p> <p></p> <p>and then click Start repositories upgrade to create a proposal.</p> <p></p> <p>On the DAO tab, vote for the proposal to create a repository.</p> <p></p> <p>After the proposal is accepted, the contract version will be upgraded.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/dao-set-up/#from-v-2-to-v-3","title":"from v. 2 to v. 3","text":"<p>Release notes</p> <p>Contracts</p> <pre><code>* Added possibility of a DAO to be a member of another DAO\n\n* Added possibility of DAO to be a Task performer. A DAO itself can now be a signer, reviewer, and manager of a Task in another DAO \u2014 Tasks now have the same functionality for DAOs as for individuals\n\n* Improve native token management in contracts. This is mainly bug fixes for the back-end blockchain tokens that guarantee the operations of a smart contract\n\n* Added possibility of task upgrade. Upgrades from Smart Contract version 2.0 to 3.0 required a redeployment of all Tasks. From now on all future upgrades will not affect previously created Tasks\n\n* Task rewards do not increase karma. From now on Tasks will only serve to remunerate contributors with DAO Tokens but without increasing their Voting Karma\n\n* Added a possibility to create index contracts. Version 3.0 now includes indexes that improve the performance of GOSH when used in a web browser\n</code></pre> <p>Interface</p> <pre><code>* DAOs can become members of other DAOs. DAOs have equal interface user flows for this operation\n\n* A DAO can be set as a Task assignee, reviewer, and manager (DAO review, receive task bounty is not implemented yet). Web browsers now also fully support Task functionality\n\n* DAO can create proposals and vote for proposals in parent DAO (not implemented yet)\n\n* ask rewards do not increase karma\n\n* If a DAO owns tokens of another DAOs \u201cDAO supply\u201d block will contain a button with details. The GOSH interface now has a block to allow DAO members to see which tokens the DAO holds\n</code></pre> <p>Git Remote Helper</p> <pre><code>* supports all functionality of Smart Contract Version 3.0\n</code></pre> <p>The Tasks were added in contracts version 2.</p> <p>Uninitialized Tasks will not be migrated to the new version. You will need to create these tasks in the new version.</p> <p>Warning</p> <p>Before starting the update make sure that there are commits in the Tasks.</p> <p>Go to the Settings tab or follow the link in the upgrade message.</p> <p></p> <p>Select the version you want to update and click Create proposal for DAO upgrade</p> <p></p> <p>You will be taken to the DAO tab with events.</p> <p></p> <p>Inside the event, you can get acquainted with the details of the proposal.</p> <p></p> <p>After accepting the proposals, the DAO update process will begin. Before continuing, you need to transfer your tokens.</p> <p>To do this, go to the Overview tab in the Your wallet balance section and click Transfer from previous version.</p> <p></p> <p>You can also do this on the Members tab.</p> <p></p> <p>Then you need to update the DAO repositories and tags. To do this, click upgrade in the information message</p> <p></p> <p>and go to the repository uprade page. Click Get repositories.</p> <p></p> <p>Then click Start repositories upgrade to create a proposal.</p> <p></p> <p>The process will be displayed below:</p> <p></p> <p>As a result, you will be redirected to the DAO events page.</p> <p></p> <p>The details of the Multi proposal can be found at the event.</p> <p></p> <p>Then click tasks upgrade page in the information message</p> <p></p> <p>and click Start tasks upgrade on the page that opens.</p> <p></p> <p></p> <p>You will be taken to the DAO tab with events.</p> <p></p> <p>After accepting the proposal, the tasks will be transferred from the previous version and the contract upgrade to version 3 will be completed.</p>"},{"location":"working-with-gosh/gosh-web/dao-set-up/#from-v-3-to-v-456061","title":"From v. 3 to v. 4/5/6.0/6.1","text":"<p>Uninitialized Tasks will not be migrated to the new version. You will need to create these tasks in the new version.</p> <p>Warning</p> <p>Before starting the update make sure that there are commits in the Tasks.</p> <p>Go to the Settings tab or follow the link in the upgrade message.</p> <p></p> <p>Select the version you want to update and click Create proposal for DAO upgrade</p> <p></p> <p>You will be taken to the DAO tab with events.</p> <p></p> <p>Inside the event, you can get acquainted with the details of the proposal.</p> <p></p> <p>After accepting the proposals, the DAO update process will begin. Before continuing, you need to transfer your tokens.</p> <p>Info</p> <p>Starting from the 5th version, tokens are transferred automatically.</p> <p>Warning</p> <p>If you have tokens that were locked into voting in previous versions of the DAO at the time of the upgrade, please note that these tokens will be transferred only after the expiration of the proposal. </p> <p>If you have a DAO version lower than the 4th inclusive, then to transfer tokens go to the Overview tab in the Your wallet balance section and click Transfer from previous version.</p> <p></p> <p>You can also do this on the Members tab.</p> <p></p> <p>Then you need to update the DAO repositories and tags. To do this, click upgrade in the information message</p> <p></p> <p>and go to the repository uprade page. Click Get repositories.</p> <p></p> <p>Then click Start repositories upgrade to create a proposal.</p> <p></p> <p>The process will be displayed below:</p> <p></p> <p>As a result, you will be redirected to the DAO events page.</p> <p></p> <p>The details of the Multi proposal can be found at the event.</p> <p></p> <p>Then click tasks upgrade page in the information message</p> <p></p> <p>and click Start tasks upgrade on the page that opens.</p> <p></p> <p></p> <p>You will be taken to the DAO tab with events.</p> <p></p> <p>After accepting the proposal, the tasks will be transferred from the previous version and the contract upgrade to version 4 will be completed.</p>"},{"location":"working-with-gosh/gosh-web/dao-set-up/#from-version-61-to-62","title":"From version 6.1 to 6.2","text":"<p>Release notes for 6.2.0</p> <ul> <li>Expert Tags have been introduced</li> </ul> <p>The list of decisions supported in this version includes:</p> <ul> <li> <p>Voting on Hackathon Results</p> </li> <li> <p>Creating a Repository with Expert Tags</p> </li> <li> <p>The Upgrade System has been improved</p> </li> <li> <p>some bugs have been fixed</p> </li> </ul> <p>Warning</p> <p>It's important to ensure that there are commits in the tasks and all proposals are completed before starting the update.</p> <p>Go to the Settings tab or follow the link in the upgrade message.</p> <p></p> <p>Select the version you want to update and click Create proposal for DAO upgrade</p> <p></p> <p>You will be redirected to the page with the DAO event and will be able to vote for this proposal.</p> <p>After accepting the proposals, the DAO update process will begin.</p> <p></p> <p>Warning</p> <p>If you have tokens that were locked into voting in previous versions of the DAO at the time of the upgrade, please note that these tokens will be transferred only after the expiration of the proposal. </p> <p>You should reload the page to continue updating your DAO.</p> <p></p> <p>Once you've done that, click on the Complete upgrade button in the message that appears</p> <p></p> <p>Then, a new window will open up and you'll need to click on \"Start upgrade complete process\" to begin the data migration process between versions of DAOs. </p> <p></p> <p>As a result, multiple proposals will be created to transfer all data from your DAO to the new version (migrating the Index repository and all Hackathons, upgrading the DAO repositories)</p> <p>After all proposals are accepted, the DAO update process can be considered complete.</p>"},{"location":"working-with-gosh/gosh-web/grh-config/","title":"Set up Git Remote Helper","text":"<p>Set up Git Remote Helper and continue working with your repository.</p> <p>You'll need your wallet credentials. Go to the main page of your account and click User Settings.</p> <p>Scroll down to the Git remote config section, click Show and unlock with PIN code</p> <p></p> <p>Download the configuration file by clicking on the icon and save it to folder <code>~/.gosh</code></p> <p></p> <p>To view the command to clone your repo, click the Clone button on your repo page.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/members/","title":"Members","text":""},{"location":"working-with-gosh/gosh-web/members/#working-with-dao-members","title":"Working with DAO Members","text":""},{"location":"working-with-gosh/gosh-web/members/#adding-members-to-dao","title":"Adding Members to DAO","text":"<p>Membership in the DAO can be obtained in several ways.</p> <p>The user can be invited to the DAO using a special form or by an invitation link.</p> <p>Also, the user can independently create a membership request in the DAO.</p> <p>Info</p> <p>Adding a member to the DAO is possible only through an proposal.</p> <p>Depending on the chosen path, tokens and Karma will be distributed immediately after acceptance proposal, or additional proposals will need to be created for this.</p>"},{"location":"working-with-gosh/gosh-web/members/#adding-by-gosh-username-or-e-mail","title":"Adding by GOSH username or e-mail","text":"<p>A DAO member can create a proposle to add GOSH user into the DAO.</p> <p>To do this, go to the tab Members in the section Invite user to DAO.</p> <ul> <li> <p>If you know the GOSH username, then enter it.</p> </li> <li> <p>If you don't know the name or the user doesn't have a GOSH account yet, enter their email address.</p> </li> </ul> <p>Info</p> <p>The email address will change to the GOSH username if the user has given permission during registration so that it can be found by email.</p> <p>Offer the amount of karma for him and please comment your decision.</p> <p>Info</p> <p>You can send an invitation proposal to several users at once.</p> <p>And click Send invite.</p> <p></p> <p>Info</p> <p>At the same time, a multi proposal will be created to add DAO members and provide voting tokens.</p> <p>Go to the DAO tab and select the desired event for voting.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/members/#invite-by-link","title":"Invite by link","text":"<p>You can invite a user to the DAO by generating an invitation link for them.</p> <p>Warning</p> <p>Enable \"Allow external users to request DAO membership\" option in DAO settings to enable invites by email/link.</p> <p>To do this, on the tab Members in the section Invite user to DAO click on Get one-time invitation link.</p> <p>Info</p> <p>The link to the invitation can only be used one time.</p> <p></p> <p>All active invitation links will be displayed in the section on the right.</p> <p>When the invited user creates a membership proposle in the DAO, the link entry disappears.</p> <p>You can also deactivate the link click on the Revoke.</p> <p></p> <p>When the user clicks the link, they will be able to create an account or log into GOSH.</p> <p></p> <p>Then input a short nickname or and click Create account and continue.</p> <p></p> <p>Enter a short comment who are you and click Accept invitation.</p> <p></p> <p>On the event page that opens, you can find a request for your acceptance as a member of the DAO.</p> <p>Click on it you can track the results of voting and discussions.</p> <p></p> <p>After the proposal is accepted, its status will change to Accepted</p> <p></p> <p>Info</p> <p>You will be able to request voting tokens after you are accepted into the DAO by creating your proposal.</p>"},{"location":"working-with-gosh/gosh-web/members/#request-dao-membership","title":"Request DAO membership","text":"<p>You can create a membership request in the DAO yourself. To do this, you need to know the link to this DAO. </p> <p>Info</p> <p>Only a registered user will be able to create a membership request.</p> <p>Follow this link and you will see the overview tab of the DAO you are interested in.</p> <p>Click Request membership.</p> <p></p> <p>In the window that opens, write who you are and why you want to become a member of this DAO. This description will help the members of the DAO to make a decision when voting.</p> <p>Then click Create proposal.</p> <p></p> <p>On the event page that opens, you can find a request for your acceptance as a member of the DAO.</p> <p></p> <p>After the DAO members vote, the status of your request will change to Accepted or Rejected</p> <p>You can follow the voting and discussion by opening the event.</p>"},{"location":"working-with-gosh/gosh-web/members/#delete-members-from-the-dao","title":"Delete Members from the DAO","text":"<p>To delete a member from the DAO, go to the Members tab and click on the cross to the desired member.</p> <p>Warning</p> <p>To create an proposal, you must have at least 20 tokens on your wallet balance.</p> <p></p> <p>Confirm the deletion by clicking OK.</p> <p></p> <p>As a result, a Multi proposal will be created and you will be redirected to the event tab Dao.</p> <p></p> <p>The details of the multi proposl can be seen by going to it.</p> <p></p> <p>After voting and accepting multi proposal, the user will be deleted from the list of members of the DAO. </p> <p></p> <p>The Karma of the deleted user will be equal to 0. But the tokens, if they were, will stay on the balance of the user's wallet.</p> <p></p> <p>Then click Save changes and create proposal. As a result, a Multi proposal will be created and you will be redirected to the event page Dao.</p> <p></p> <p>Inside the event, you can get details of Multi proposal.</p> <p></p> <p>After accepting the multi proposal, the user will receive tokens and Karma from DAO reserve. This can be seen on the Members tab</p> <p></p>"},{"location":"working-with-gosh/gosh-web/proposals-and-voting-in-smv/","title":"Proposals and voting in SMV","text":""},{"location":"working-with-gosh/gosh-web/proposals-and-voting-in-smv/#proposals-and-voting-in-smv-soft-majority-vote","title":"Proposals and voting in SMV (Soft Majority Vote)","text":"<p>The main mechanism of interaction in the DAO is voting. Any action in a DAO requires a vote and is created through Proposals, and a soft-majority vote (SMV) of all other DAO members may be required to approve it. </p> <p>Warning</p> <p>To create an proposal, you must have at least 20 tokens on your wallet balance.</p>"},{"location":"working-with-gosh/gosh-web/proposals-and-voting-in-smv/#types-of-proposals","title":"Types of Proposals:","text":"<ul> <li>Create a pull request</li> <li>Add branch protection</li> <li>Remove branch protection</li> <li>Add DAO member</li> <li>Remove DAO member</li> <li>Upgrade DAO</li> <li>Create task</li> <li>Delete task</li> <li>Create repository</li> <li>Add voting tokens</li> <li>Add regular tokens</li> <li>Mint DAO tokens</li> </ul> <ul> <li>Disable minting DAO tokens</li> <li>Change DAO member Karma</li> </ul> <ul> <li> <p>Multi proposal - includes several offers at once. </p> <p>For example: providing the membership to the DAO by the member of the DAO</p> </li> </ul> <ul> <li>Allow event discussions</li> <li>Show event progress</li> </ul> <ul> <li>Ask DAO membership allowance</li> </ul>"},{"location":"working-with-gosh/gosh-web/proposals-and-voting-in-smv/#voting-procedure","title":"Voting procedure","text":"<p>To vote for the proposal, some of your tokens must be be allocated to SMV (once the proposal is completed), you can get them back.</p> <p>Info</p> <p>You can vote for a proposal only once.</p> <p>For example, to merge into main, create a pull request from some other branch. A proposal will be generated and will appear on the DAO tab.</p> <p>Open the proposal and review the contents.</p> <p>The voting period is indicated on the proposal page. This is the time allotted for voting.</p> <p>Unless a decisive majority of &gt;50% Global Karma Count is achieved early, votes will be counted at the end of this period.</p> <p>Info</p> <p>Global Karma Count is the total amount of Karma calculated by summing up the Karma of all DAO members at the time of the proposal creation.</p> <p>Once you have made a decision, input the amount of tokens, select Approve or Reject and click Vote for proposal. Vote registration can take a bit of time.</p> <p>Info</p> <p>As per the rules of Soft Majority Voting, to have a proposal approved early, you need at least 50% of the total supply of tokens in the repository + 1 token used to vote for the proposal.</p> <p>For example, in a repository with two members, where the total supply of tokens is 200, 101 token needs to be used to instantly approve a proposal. Thus with every member holding 100 tokens a proposal can never be instantly completed without the participation of members other than the proposal's author.</p> <p>On the other hand, so as not to depend on all members of an organization to vote, soft majority vote will complete with an approval at the end of the voting period, if 10% of the total token supply were used to vote for, and no one voted against.</p> <p>The more tokens are sent against the proposal, the higher the approving amount needs to be (up to 50% of the total supply  + 1 token) for the proposal to pass.</p> <p>Other members of the Organization, who have transferred their tokens to SMV, will be able to vote for the proposal on this page in their own accounts.</p> <p>Info</p> <p>Currently, even in organizations with a single member, voting still takes place when a proposal is created. 51 tokens are needed to approve a proposal in such a repository.</p> <p>Once a majority has been reached early, or the voting period ended and the soft majority vote result was decided, the proposal completes and the proposed action is performed.</p>"},{"location":"working-with-gosh/gosh-web/repository/","title":"Repository","text":""},{"location":"working-with-gosh/gosh-web/repository/#create-repository","title":"Create Repository","text":"<p>To create a repository in your DAO click Create new in the Repositories section or Overview section.\u200b</p> <p></p> <p>Enter repository name and its description and click Create repository.</p> <p>Warning</p> <p>The repository name must contain only Latin letters, numbers,hyphen, underscore character<code>( a...z, 0...9, -, _ )</code></p> <p></p> <p>A page with DAO events will open for you.</p> <p></p> <p>Open the event click on its name.</p> <p></p> <p>The page that opens displays the name of the proposal, its status, and the time of creation and as well as the end of voting.</p> <p></p> <p>The scale shows the number of votes for the proposal and against.</p> <p></p> <p>Specify the number of tokens less than or equal to your Karma for voting and accept or reject this proposal.</p> <p>Add your opinion about the proposal to the discussion below and click Send vote</p> <p></p> <p>The created repository will appear in the list on the Repositories tab.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/repository/#create-repository-with-expert-tags","title":"create repository with Expert Tags","text":"<p>This will provide every Tag holder with increased Karma Powers when voting on commits, and for branch protection and unprotection.</p>"},{"location":"working-with-gosh/gosh-web/repository/#create-branch","title":"\u200bCreate Branch","text":"<p>Repository is created with default main branch. To create another branch, click on the branches counter.\u200b</p> <p></p> <p>Select the branch to be forked, enter new branch name, and click\u200b Create branch.</p> <p>Warning</p> <p>The branch name must contain only Latin letters, numbers, hyphen, underscore character <code>( a...z, 0...9, -, _ )</code></p> <p></p> <p>Once the branch is created, it will appear in the branches list.</p> <p></p> <p>Switch to it via drop down list.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/repository/#create-file","title":"Create File","text":"<p>To create file, click Add file button.</p> <p></p> <p>Enter file contents and name.</p> <p></p> <p>You can use Preview if needed. MD syntax is supported for preview.</p> <p>After scroll down and enter commit info:</p> <ul> <li> <p>Commit description - you can add a description of your commit;</p> </li> <li> <p>Commit tags - this is a mutable pointer of the commit. You can add the tag to quickly go to this commit and see what has been done;</p> </li> <li> <p>Select task - if the branch is not protected and your file is a solution to a problem, you can choose a particular task;</p> </li> <li> <p>and add Assigners, Reviewers and Managers if necessary.</p> </li> </ul> <p>and click Commit changes</p> <p></p> <p>If the branch you are working in requires no voting to confirm commits, the file will be added. Otherwise a DAO vote will be initiated.</p> <p>Commit status will be displayed below.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/repository/#create-pull-request","title":"Create Pull Request","text":"<p>Click on the Pull requests tab and set up the pull request: what branch to merge from and to. Once selected, click Compare.</p> <p></p> <p>The branches will be compared. Review the changes, set up the pull request and click Commit changes.</p> <p></p> <p>Info</p> <p>Note: When merging into the main branch, and in some other cases (depending on DAO setup), a DAO proposal will be initiated by trying to commit.</p> <p>Organization Tokens have to be sent to the DAO Soft Majority Vote contract to start a proposal for DAO members to vote on.</p>"},{"location":"working-with-gosh/gosh-web/repository/#add-protection-for-a-branch","title":"Add protection for a branch","text":"<p>If you want the changes to be added to the branch based on the voting results, then add protection to the branch.</p> <p>This can be done by creating an appropriate proposal.</p> <p>To do this, go from the Repositories tab to the repository you need.</p> <p></p> <p>Then, on the Branches tab, click the Protect button for the branch to which you want to add protection.</p> <p></p> <p>After creating the proposal, you will be redirected to the DAO page with events.</p> <p></p> <p>Inside the event, you can get details of proposal.</p> <p></p> <p>After the proposal is accepted the branch is marked as protected. A commit can be made to it only by voting.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/repository/#remove-protection-for-a-branch","title":"Remove protection for a branch","text":"<p>If the branch no longer needs protection, you can remove it by initiating appropriate proposals.</p> <p>To do this, go from the Repositories tab to the repository you need.</p> <p></p> <p>Then, on the Branches tab, click the Unprotect button for the branch to which you want to add protection.</p> <p></p> <p>A vote will be created and you will be redirected to the DAO page with events.</p> <p></p> <p>Inside the event, you can get details of proposal.</p> <p></p> <p>After accepting the proposal, the protection mark will be removed from the branch. Now everyone can upload changes to the branch without voting.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/repository/#adding-comments-to-file","title":"Adding comments to file","text":"<p>You can add a comment to any line in the file.</p> <p>Info</p> <p>Comments are linked to a specific comment.</p> <p>To do this, open the file and hover over a line or block of lines and click on the blue icon that appears on the left.</p> <p>In the window that opens, enter your comment and click on the blue circle with an arrow to send it.</p> <p></p> <p>The comment line will be marked with a red icon on the left.</p> <p></p> <p>A thread of comments and replies to them will open on the right.</p> <p></p> <p>The discussion can be resolved. To do this, click the appropriate button:</p> <p></p> <p>Info</p> <p>The discussion can be resumed if a new comment has been added to it.</p> <p>Up to 3 discussions can be expanded in one line. You can switch between them.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/repository/#adding-comments-to-pull-request","title":"Adding comments to Pull Request","text":"<p>You can also add comments to Pull Request. To do this, go from the DAO events page to the Pull Request vote in the Pull request diff section. you can leave comments on any line or block of lines in the same way as in commenting on a file.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/task/","title":"Tasks","text":"<p>Milestone is an important tool for project management and achieving set goals. A Milestone is a set of Tasks that must be completed to reach a key stage in the project.</p> <p>The participants include:</p> <p>Assigners who are responsible for task completion; Reviewers who check for accuracy; Managers who create and manage the Milestone and break it down into Tasks.</p> <p>Milestone is used to track progress, identify potential issues, and adjust plans as needed. It also helps maintain team motivation and ensures timely and budgeted project implementation.</p> <p>Once all Tasks in the Milestone are completed and Reviewers verify their accuracy, the Milestone will be completed. Each team member who completes Tasks within the Milestone will receive a reward according to predefined distribution rules.</p>"},{"location":"working-with-gosh/gosh-web/task/#create-milestone","title":"Create Milestone","text":"<p>To create a Milestone, go to the Tasks tab and click Create milestone</p> <p></p> <p>Then you need to fill in the Milestone conditions:</p> <p></p> <ul> <li> <p>Write the Milestone name.</p> </li> <li> <p>Write the username of the Manager who will lead the Milestone execution process.</p> </li> <li> <p>And specify the Manager reward - the amount of tokens he will receive upon completion of the Milestone.</p> </li> </ul> <p>Info</p> <p>The maximum quantity of tokens from the DAO reserve available for distribution is indicated for reference.</p> <p></p> <ul> <li>Select the Repository where the pull requests will be created based on the results of work on this Milestone.</li> </ul> <p></p> <ul> <li>Specify Budget - the amount of tokens that will be paid from the DAO reserve to its execution Assigners and Reviewers.</li> </ul> <p>Attention</p> <p>The total Milestone budget consists of the Budget listed here and the Manager reward</p> <p></p> <ul> <li>Select Vesting - rules for governing the transfer of tokens at the disposal of the participants in equal portion.</li> </ul> <p>Lock period (cliff) - the period after which the reward payments will begin.  The countdown will start after accepting the proposal about completing the Milestone. Vesting period - the period during which remuneration will be paid to contractors in equal parts.</p> <p>For example, lock - 12 months, vesting - 20 months.  </p> <p>Warning</p> <p>For the investment scheme to be correct, the Mil\u0435stone budget must be a multiple of the number of months of investment.</p> <p></p> <ul> <li>By using up to 3 relevant keywords separated by spaces as tags, you can easily find and filter specific Milestone later on.</li> </ul> <p></p> <p>After filling in all the conditions, click Create milestone</p> <p></p> <p>After creating the proposal, you will be redirected to the DAO tab on the event page.</p> <p>Inside the proposal you will be able to see all the conditions of the Milestone. In the table you can see the period since which month and in what parts the payments will be made to Milestone participants.</p> <p></p> <p>Info</p> <p>When creating the Milestone the tokens (Budget) from the DAO-reserve are written off and reserved on the Task-contract.</p> <p>After accepting the proposal, the Milestone will appear in the list on the Tasks tab with the status In progress.</p> <p></p> <p>Important!</p> <p>Each participant of the DAO can create a Milestone, but only the Manager assigned to this milestone can add Tasks to it.</p> <p>Plan out what tasks your Milestone will consist of. Each task is assigned separately.  </p> <p>To add Tasks to the Milestone, open it by clicking on the one you need in the list. Then click the Add task...</p> <p>To add Tasks to your Milestone, simply open the Milestone by clicking on the one you want in the list. Then, click the \"Add task...\" button.</p> <p></p> <p>A window will open up where you can enter the task details. Make sure the name of the Milestone and the Repository where materials for the solution are collected are correct.</p> <p></p> <p>Enter the Task name. A Reward will be given for each Task completed, and Tags will be added for quick navigation.</p> <p>At the same time, you can decide on the number of tokens that the Task executor (Commit author for accepted merge), the reviewer and the manager will receive if they work on the Task. To do this, click on the Distribution</p> <p>Commit author - the person who executes the Task. Reviewer - the person who checks the correctness of the Task. Manager - the person who manages the Task execution process.</p> <p></p> <p>Info</p> <p>If the shares are not used, they will be returned to the DAO's reserve.</p> <p>After completing the filling, click Add task to milestone</p> <p></p> <p>A Milestone with Tasks will look like this:</p> <p></p> <p>Inside the Task you will be able to see all the conditions. In the table you can see the period starting from which month and in which parts the payment will be made to the Task executor. Vesting and lock periods as in Milestone.</p> <p></p> <p>Any member of the Dao can complete the Task and receive a reward. To do this, he needs to create a Branch in the Repository specified in Milestone, commit all files with the solution and create and merge pull request</p> <p></p> <p>For each file, select the task to which it belongs:</p> <p></p> <p>And also enter the names of those who worked on this Task</p> <p></p> <p>And click Commit changes</p> <p>Warning</p> <p>If a task has been selected, then a proposal is required. Select the appropriate checkbox.</p> <p>After the file has been created, the extraction request will await the reviewer's evaluation and approval of the proposal:</p> <p></p> <p>Then, after the reviewer send the solution, it will be possible to vote for the proposal. When the pull request is accepted, the Task status will change to Confirmed.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/task/#delet-milestone","title":"Delet\u0435 Milestone","text":"<p>To delete a Milestone, go to it on the Tasks tab, open it by clicking on the one you need in the list. Then click to Delete milestone</p> <p></p> <p>After creating a proposal about deleting a Task, you will be redirected to the event tab Dao.</p> <p></p> <p>When the proposal is accepted, the Task will be deleted. The tokens allocated for this Task will be returned to the DAO reserve.</p>"},{"location":"working-with-gosh/gosh-web/working-with-tokens-and-karma/","title":"Working with tokens and Karma","text":""},{"location":"working-with-gosh/gosh-web/working-with-tokens-and-karma/#additional-minting-of-tokens-for-dao","title":"Additional minting of tokens for DAO","text":"<p>Warning</p> <p>The option allowing the minting of DAO tokens must be enabled on the Settings tab in the Token Settings section.</p> <p>Click on the Mint button on the right on the Overview tab in the DAO Reserve section. You will create an proposal to mint additional tokens for this DAO.</p> <p>In the window that appears, enter the amount of tokens to emission and add a description of the DAO members. Then click Create proposal to mint tokens</p> <p></p> <p>After creating the proposal, you will be redirected to the DAO tab with events.</p> <p></p> <p>Inside the event, you can get details of proposal.</p> <p></p> <p>After the proposal is accepted, the changes will take effect.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/working-with-tokens-and-karma/#additional-voiting-tokens-and-karma","title":"Additional voiting tokens and Karma","text":"<p>Any member of the DAO can send a request to change Karma. To do this, go to the Members tab and change the number of Karma and token balance of one or more DAO members, including for yourself.</p> <p>Warning</p> <p>To create an proposal, you must have at least 20 tokens on your wallet balance.</p> <p></p> <p>Warning</p> <p>Be careful when distributing karma among the members of the DAO. Avoid the possibility of a preponderance in the votes of one of the DAO members. To avoid a situation where one participant will be able to transfer the entire balance of the DAO to his wallet.</p> <p>Then click Save changes and create proposal. As a result, a Multi proposal will be created and you will be redirected to the event tab Dao.</p> <p></p> <p>Inside the event, you can get details of Multi proposal.</p> <p></p> <p>After accepting the multi proposal, the user will receive tokens and Karma from DAO reserve. This can be seen on the Members tab.</p> <p></p>"},{"location":"working-with-gosh/gosh-web/working-with-tokens-and-karma/#expert-tags","title":"Expert Tags","text":"<p>You can now add an Karma Tags to your DAO, which will grant additional Karma Voting Powers to each member possessing such Tags for decisions that support Karma Tags.</p>"},{"location":"working-with-gosh/gosh-web/working-with-tokens-and-karma/#transfer-of-tokens-from-dao-reserve","title":"Transfer of tokens from DAO reserve","text":"<p>Tokens can be sent from the DAO reserve to</p> <ul> <li>a member of this DAO;</li> <li>any GOSH user, who has visited this DAO at least once.</li> </ul> <p>To do this, on the Overview tab in the DAO reserve section, click Send.</p> <p></p> <p>In the window that opens, enter the name of the GOSH user or the name of the DAO and the amount of tokens to send.</p> <p>If you want the recipient's Karma to increase jointly with the token balance, then check this box. Also write a description for the token transfer. This will help the DAO members to make a decision when voting.</p> <p>Warning</p> <p>Be careful when distributing karma among the members of the DAO. Avoid the possibility of a preponderance in the votes of one of the DAO members. To avoid a situation where one participant will be able to transfer the entire balance of the DAO to his wallet.</p> <p>Then click Create proposal to send tokens</p> <p></p> <p>After creating the offer, you will be redirected to the DAO page with events.</p> <p></p> <p>Inside the event, you can see detailed information about the proposal.</p> <p></p> <p>After the proposal is accepted, the tokens will be transferred to the balance wallet of the GOSH user or DAO.</p>"},{"location":"working-with-gosh/gosh-web/working-with-tokens-and-karma/#transfer-of-tokens-from-users-wallet","title":"Transfer of tokens from user's wallet","text":"<p>Tokens can be sent from the DAO reserve to</p> <ul> <li>a member of this DAO;</li> <li>any GOSH user, who has visited this DAO at least once.</li> </ul> <p>Info</p> <p>Only regular tokens are transferred. You will not be able to vote with such tokens.</p> <p>To send tokens from your wallet to the DAO, go to the Overview or DAO tab on the Your wallet balance section and click Send.</p> <p></p> <p>In the window that opens, enter the name of the member of the DAO and the amount of tokens to send. Then click Send tokens</p> <p></p> <p>After that, the tokens will be transferred to the recipient's wallet balance.</p> <p></p>"}]}